import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import cv2
import os
from PIL import Image, ImageTk
import time
from scipy.ndimage import gaussian_filter

class GSDepthMapperGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("G-S Alignment Depth Mapper - Fixed Quantum Method v5")
        self.root.geometry("1400x900")
        
        # Data storage
        self.alignment_data = []
        self.perfect_alignments = []
        self.current_depth_map = None
        self.current_coords = None
        self.loaded_image = None
        self.image_data = None
        
        # Default parameters
        self.resolution = tk.IntVar(value=256)
        self.colormap = tk.StringVar(value="viridis")
        self.nuit_radius = tk.DoubleVar(value=0.5) 
        
        # Image processing parameters
        self.hadit_theta = tk.DoubleVar(value=45.0)
        self.hadit_phi = tk.DoubleVar(value=60.0)
        self.depth_method = tk.StringVar(value="luminosity")
        self.depth_scale = tk.DoubleVar(value=1.0)
        self.depth_contrast = tk.DoubleVar(value=1.0)
        self.gs_scale = tk.DoubleVar(value=1.0) # This might be re-evaluated or used as R_sphere if not 1.0
        
        # Full sampling control
        self.full_sampling = tk.BooleanVar(value=True)
        self.processing_cancelled = False
        
        self.setup_gui()
        
    def setup_gui(self):
        """Setup the main GUI layout."""
        control_container = ttk.Frame(self.root)
        control_container.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
        
        viz_frame = ttk.Frame(self.root)
        viz_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.setup_scrollable_control_panel(control_container)
        self.setup_visualization_panel(viz_frame)
        
    def setup_scrollable_control_panel(self, parent):
        """Setup a scrollable control panel."""
        canvas = tk.Canvas(parent, width=350, highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        def _bind_to_mousewheel(event):
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        def _unbind_from_mousewheel(event):
            canvas.unbind_all("<MouseWheel>")
        
        canvas.bind('<Enter>', _bind_to_mousewheel)
        canvas.bind('<Leave>', _unbind_from_mousewheel)
        
        self.setup_control_panel(scrollable_frame)
        
    def setup_control_panel(self, parent):
        """Setup the control panel content."""
        title_label = ttk.Label(parent, text="G-S Depth Mapper", font=("Arial", 16, "bold"))
        title_label.pack(pady=(0, 20))
        
        image_frame = ttk.LabelFrame(parent, text="Step 1: Load Data", padding=10)
        image_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(image_frame, text="ðŸ“ Load Image File", 
                  command=self.load_image, width=25).pack(fill=tk.X, pady=2)
        
        ttk.Button(image_frame, text="ðŸ“Š Load G-S Alignment Data", 
                  command=self.load_alignment_data, width=25).pack(fill=tk.X, pady=2)
        
        self.image_status_label = ttk.Label(image_frame, text="No data loaded", foreground="red")
        self.image_status_label.pack(pady=5)
        
        params_frame = ttk.LabelFrame(parent, text="Step 2: Processing Parameters", padding=10)
        params_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(params_frame, text="Depth Method:").pack(anchor=tk.W)
        methods = [
            ("Luminosity (Brightness)", "luminosity"),
            ("RGB Magnitude", "rgb_magnitude"),
            ("Saturation", "saturation"),
            ("G-S Coordinate (Geometric Depth)", "gs_coordinate_geometric"), # Renamed for clarity
            ("Edge Detection", "edges")
        ]
        
        for text, value in methods:
            ttk.Radiobutton(params_frame, text=text, variable=self.depth_method, 
                           value=value).pack(anchor=tk.W)
        
        ttk.Label(params_frame, text="Depth Scale:").pack(anchor=tk.W, pady=(10, 0))
        scale_frame = ttk.Frame(params_frame)
        scale_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(scale_frame, from_=0.1, to=5.0, variable=self.depth_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(scale_frame, textvariable=self.depth_scale, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(params_frame, text="Depth Contrast:").pack(anchor=tk.W, pady=(10, 0))
        contrast_frame = ttk.Frame(params_frame)
        contrast_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(contrast_frame, from_=0.1, to=3.0, variable=self.depth_contrast, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(contrast_frame, textvariable=self.depth_contrast, width=8).pack(side=tk.RIGHT)
        
        gs_frame = ttk.LabelFrame(params_frame, text="G-S Parameters (for G-S Geometric Depth)", padding=5)
        gs_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Checkbutton(gs_frame, text="Full pixel sampling (higher quality, slower)", 
                       variable=self.full_sampling).pack(anchor=tk.W, pady=(0, 5))
        
        ttk.Label(gs_frame, text="Hadit Î¸ (degrees):").pack(anchor=tk.W)
        theta_frame = ttk.Frame(gs_frame)
        theta_frame.pack(fill=tk.X)
        ttk.Scale(theta_frame, from_=0, to=360, variable=self.hadit_theta, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(theta_frame, textvariable=self.hadit_theta, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="Hadit Ï† (degrees):").pack(anchor=tk.W)
        phi_frame = ttk.Frame(gs_frame)
        phi_frame.pack(fill=tk.X)
        ttk.Scale(phi_frame, from_=0, to=180, variable=self.hadit_phi, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(phi_frame, textvariable=self.hadit_phi, width=8).pack(side=tk.RIGHT)
        
        # Nuit Radius is not directly used by the new geometric depth but kept for other contexts or future use
        ttk.Label(gs_frame, text="Nuit Radius (Contextual):").pack(anchor=tk.W)
        nuit_frame = ttk.Frame(gs_frame)
        nuit_frame.pack(fill=tk.X)
        ttk.Scale(nuit_frame, from_=0.1, to=2.0, variable=self.nuit_radius, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(nuit_frame, textvariable=self.nuit_radius, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="G-S Scale Factor (Sphere Radius):").pack(anchor=tk.W)
        gs_scale_frame = ttk.Frame(gs_frame)
        gs_scale_frame.pack(fill=tk.X)
        ttk.Scale(gs_scale_frame, from_=0.1, to=10.0, variable=self.gs_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(gs_scale_frame, textvariable=self.gs_scale, width=8).pack(side=tk.RIGHT)
        
        process_frame = ttk.LabelFrame(parent, text="Step 3: Process Image", padding=10)
        process_frame.pack(fill=tk.X, pady=(0, 10))
        
        button_frame = ttk.Frame(process_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.process_button = ttk.Button(button_frame, text="ðŸ”„ Process Image to Depth Map", 
                                        command=self.process_image_to_depth_map, 
                                        width=20, state="disabled")
        self.process_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        
        self.cancel_button = ttk.Button(button_frame, text="âŒ Cancel", 
                                       command=self.cancel_processing, 
                                       width=8, state="disabled")
        self.cancel_button.pack(side=tk.RIGHT)
        
        self.process_status_label = ttk.Label(process_frame, text="Load data first", foreground="orange")
        self.process_status_label.pack(pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(process_frame, variable=self.progress_var, 
                                          maximum=100, length=300)
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        viz_frame_control = ttk.LabelFrame(parent, text="Step 4: Visualization", padding=10)
        viz_frame_control.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(viz_frame_control, text="Resolution:").pack(anchor=tk.W)
        resolution_frame = ttk.Frame(viz_frame_control)
        resolution_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(resolution_frame, from_=64, to=1024, variable=self.resolution, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(resolution_frame, textvariable=self.resolution, width=5).pack(side=tk.RIGHT)
        
        ttk.Label(viz_frame_control, text="Colormap:").pack(anchor=tk.W, pady=(10, 0))
        colormap_combo = ttk.Combobox(viz_frame_control, textvariable=self.colormap, 
                                     values=["viridis", "plasma", "hot", "coolwarm", 
                                            "jet", "terrain", "ocean", "rainbow", "gray"])
        colormap_combo.pack(fill=tk.X, pady=2)
        
        self.update_viz_button = ttk.Button(viz_frame_control, text="ðŸŽ¨ Update Visualization", 
                                           command=self.update_visualization, 
                                           state="disabled")
        self.update_viz_button.pack(fill=tk.X, pady=5)
        
        self.select_condition_button = ttk.Button(viz_frame_control, text="ðŸŽ›ï¸ Select Conditions", 
                                                 command=self.select_alignment_condition, 
                                                 state="disabled")
        self.select_condition_button.pack(fill=tk.X, pady=2)
        
        debug_frame = ttk.LabelFrame(viz_frame_control, text="Debug Info", padding=5)
        debug_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.debug_label = ttk.Label(debug_frame, text="No processing done yet", font=("Courier", 8))
        self.debug_label.pack(fill=tk.X)
        
        export_frame = ttk.LabelFrame(parent, text="Step 5: Export", padding=10)
        export_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.export_button = ttk.Button(export_frame, text="ðŸ’¾ Export Depth Map", 
                                       command=self.export_depth_map, 
                                       state="disabled")
        self.export_button.pack(fill=tk.X, pady=2)
        
        quick_frame = ttk.LabelFrame(parent, text="Quick Test", padding=10)
        quick_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(quick_frame, text="ðŸ§ª Load Sample Data", 
                  command=self.load_sample_data).pack(fill=tk.X, pady=2)
        
        ttk.Button(quick_frame, text="ðŸŽ¯ Test G-S Method", 
                  command=self.test_gs_method).pack(fill=tk.X, pady=2)
        
        ttk.Label(parent, text=" ").pack(pady=20)
        
    def setup_visualization_panel(self, parent):
        self.fig = Figure(figsize=(12, 10), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.fig, parent)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        toolbar_frame = ttk.Frame(parent)
        toolbar_frame.pack(fill=tk.X)
        
        from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
        toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
        toolbar.update()
        
        self.show_empty_plot()
    
    def show_empty_plot(self):
        self.fig.clear()
        ax = self.fig.add_subplot(111)
        ax.text(0.5, 0.5, "Load data to get started!\n\n1. Click 'Load Image File' or 'Load G-S Alignment Data'\n2. Adjust parameters if needed\n3. Click 'Process Image to Depth Map' (for images)\n4. [...]",
                ha='center', va='center', fontsize=14, transform=ax.transAxes)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_title("G-S Depth Mapper - FIXED Quantum Method (v5)")
        self.canvas.draw()
    
    def load_image(self):
        filename = filedialog.askopenfilename(
            title="Select Image File",
            filetypes=[("Image files", "*.png *.jpg *.jpeg *.tiff *.tif *.bmp *.gif"), ("All files", "*.*")]
        )
        if filename:
            try:
                pil_image = Image.open(filename)
                if pil_image.mode != 'RGB':
                    pil_image = pil_image.convert('RGB')
                self.loaded_image = pil_image
                self.image_data = np.array(pil_image)
                self.image_status_label.config(
                    text=f"âœ… Loaded: {os.path.basename(filename)} ({self.image_data.shape[1]}x{self.image_data.shape[0]})",
                    foreground="green"
                )
                self.process_button.config(state="normal")
                self.process_status_label.config(text="Ready to process image", foreground="blue")
                self.show_loaded_image()
                messagebox.showinfo("Success", f"Image loaded: {os.path.basename(filename)}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load image: {str(e)}")
    
    def load_alignment_data(self):
        filename = filedialog.askopenfilename(
            title="Select G-S Alignment Data File",
            filetypes=[("Text files", "*.txt"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            try:
                self.parse_gs_alignment_file(filename)
                messagebox.showinfo("Success", f"G-S alignment data loaded from {os.path.basename(filename)}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load alignment data: {str(e)}")

    def parse_gs_alignment_file(self, filename):
        with open(filename, 'r') as f:
            content = f.read()
        lines = content.split('\n')
        total_alignments_from_summary = 0
        for line in lines:
            if "Total alignments found:" in line:
                total_alignments_from_summary = int(line.split(":")[1].strip())
                break
        
        all_alignments = []
        current_condition = None
        parsing_data = False
        
        for line in lines:
            line = line.strip()
            if "CONDITION:" in line and "PROJECTION" in line:
                current_condition = line.replace("CONDITION: ", "").strip()
                parsing_data = False
                continue
            if line.startswith("G_theta_deg,G_phi_deg,Hadit_theta_deg"):
                parsing_data = True
                continue
            if parsing_data and line and not line.startswith("=") and "," in line:
                try:
                    parts = line.split(',')
                    if len(parts) >= 11:
                        alignment = {
                            'condition': current_condition,
                            'G_theta': float(parts[0]), 'G_phi': float(parts[1]),
                            'Hadit_theta': float(parts[2]), 'Hadit_phi': float(parts[3]),
                            'S_x': float(parts[4]), 'S_y': float(parts[5]),
                            'dist_boundary': float(parts[6]), 'dist_origin': float(parts[7]),
                            'G_refl_x': float(parts[8]), 'G_refl_y': float(parts[9]),
                            'G_refl_z': float(parts[10])
                        }
                        all_alignments.append(alignment)
                except (ValueError, IndexError):
                    continue
            if parsing_data and line.startswith("="):
                parsing_data = False
        
        self.alignment_data = all_alignments
        self.create_depth_map_from_alignments(all_alignments) # Default to showing all
        self.image_status_label.config(
            text=f"âœ… G-S data: {len(all_alignments)} alignments", foreground="green"
        )
        self.select_condition_button.config(state="normal")
        print(f"Loaded {len(all_alignments)} G-S alignments from {total_alignments_from_summary} total (summary)")

    def create_depth_map_from_alignments(self, alignments, grid_size=None):
        if not alignments:
            self.current_depth_map = None
            self.current_coords = None
            self.show_empty_plot() # Or a message
            return

        if grid_size is None:
            grid_size = self.resolution.get()

        # Determine depth based on projection type and G_refl components
        depth_values = []
        s_x_coords = [a['S_x'] for a in alignments]
        s_y_coords = [a['S_y'] for a in alignments]

        # Assuming the first alignment's condition is representative for projection type if mixed
        # Or ideally, this function is called with alignments from a single condition.
        # For now, let's be robust. If conditions vary, this needs careful thought.
        # We'll use the G_refl component orthogonal to the S_x, S_y plane.
        # This requires knowing what S_x and S_y represent for each condition.

        # For simplicity, if we are just visualizing the *loaded alignment data*,
        # the depth should be the G_refl component orthogonal to the S_x, S_y plane.
        # This means we need to parse the condition string to determine the plane.
        
        processed_depth_values = []
        valid_s_x = []
        valid_s_y = []

        for a in alignments:
            condition_str = a.get('condition', '').upper()
            depth_val = 0
            # The S_x, S_y from file are already the 2D projection coordinates.
            # We need the G_refl component that is *orthogonal* to that projection plane.
            if "XY PROJECTION" in condition_str:
                depth_val = a['G_refl_z']
            elif "XZ PROJECTION" in condition_str: # S_x is G_refl_x, S_y is G_refl_z
                depth_val = a['G_refl_y']
            elif "YZ PROJECTION" in condition_str: # S_x is G_refl_y, S_y is G_refl_z
                depth_val = a['G_refl_x']
            else: # Fallback or unknown condition, use a default or skip
                # Using dist_origin as a placeholder if projection unknown, or skip
                # depth_val = a['dist_origin'] 
                continue # Skip if condition is not clear for geometric depth
            
            processed_depth_values.append(depth_val)
            valid_s_x.append(a['S_x'])
            valid_s_y.append(a['S_y'])

        if not valid_s_x: # No valid alignments to process
            self.current_depth_map = np.zeros((grid_size, grid_size))
            self.current_coords = np.meshgrid(np.linspace(0,1,grid_size), np.linspace(0,1,grid_size))
            self.update_visualization() # Show empty or error
            return

        s_x_coords = valid_s_x
        s_y_coords = valid_s_y
        depth_values = processed_depth_values
            
        x_min, x_max = min(s_x_coords), max(s_x_coords)
        y_min, y_max = min(s_y_coords), max(s_y_coords)
        
        depth_map = np.zeros((grid_size, grid_size))
        count_map = np.zeros((grid_size, grid_size))
        
        for sx, sy, depth in zip(s_x_coords, s_y_coords, depth_values):
            if x_max > x_min: grid_x = int((sx - x_min) / (x_max - x_min) * (grid_size - 1))
            else: grid_x = grid_size // 2
            if y_max > y_min: grid_y = int((sy - y_min) / (y_max - y_min) * (grid_size - 1))
            else: grid_y = grid_size // 2
            
            grid_x = max(0, min(grid_size - 1, grid_x))
            grid_y = max(0, min(grid_size - 1, grid_y))
            
            depth_map[grid_y, grid_x] += depth
            count_map[grid_y, grid_x] += 1
        
        valid_mask = count_map > 0
        depth_map[valid_mask] /= count_map[valid_mask]
        
        # Fill NaN values that might result from division by zero if a cell had 0 count but somehow got sum
        depth_map[np.isnan(depth_map)] = 0 

        # Smoothing - only apply if some points exist
        if np.any(valid_mask):
            # Create a copy for smoothing to avoid modifying the original average in-place before blending
            depth_map_for_smoothing = np.copy(depth_map)
            # For cells with no data, they are 0. Gaussian filter will spread from actual data points.
            # If we want to preserve actual zeros vs no-data zeros, more complex masking is needed.
            # For now, smooth the whole map, including zeros.
            smoothed_depth = gaussian_filter(depth_map_for_smoothing, sigma=2.0)
            
            # Blend: Use averaged data where available, smoothed data elsewhere or blend.
            # If a cell had data (valid_mask is True), use its averaged value.
            # If a cell had no data (valid_mask is False), use the smoothed value.
            final_depth = np.where(valid_mask, depth_map, smoothed_depth)
        else: # No valid data points at all
            final_depth = depth_map # Should be all zeros

        # Normalize to [0,1] for visualization if desired, or keep physical depth values
        # The G_refl components are typically [-1, 1].
        # To map to a typical depth map range [0,1], we can shift and scale:
        # final_depth = (final_depth - final_depth.min()) / (final_depth.max() - final_depth.min() + 1e-9) # Avoid div by zero
        # For now, let's keep the direct G_refl component values as depth.

        self.current_depth_map = final_depth
        height, width = final_depth.shape
        x_coords_grid = np.linspace(x_min, x_max, width)
        y_coords_grid = np.linspace(y_min, y_max, height) # y-axis for imshow is typically inverted
        self.current_coords = np.meshgrid(x_coords_grid, y_coords_grid)
        
        self.update_viz_button.config(state="normal")
        self.export_button.config(state="normal")
        self.process_status_label.config(text="âœ… G-S alignment depth map created (Geometric Depth)", foreground="green")
        
        unique_points = np.count_nonzero(valid_mask)
        debug_text = (f"G-S Alignment Data (Geometric Depth)\nTotal valid alignments: {len(depth_values)}\n"
                      f"Unique grid points: {unique_points}\n"
                      f"S_x range: [{x_min:.3f}, {x_max:.3f}]\nS_y range: [{y_min:.3f}, {y_max:.3f}]\n"
                      f"Depth (G_refl_ortho) range: [{final_depth.min():.4f}, {final_depth.max():.4f}]")
        self.debug_label.config(text=debug_text)
        
        self.visualize_gs_alignment_depth_map(alignments) # Pass original full alignments for scatter plot

    def visualize_gs_alignment_depth_map(self, alignments_for_scatter): # Renamed param
        if self.current_depth_map is None or self.current_coords is None:
            return
        
        self.fig.clear()
        gs_gridspec = self.fig.add_gridspec(2, 2, hspace=0.4, wspace=0.3) # Adjusted spacing
        
        ax1 = self.fig.add_subplot(gs_gridspec[0, :])
        #imshow origin='lower' to match S_x, S_y typical cartesian plot
        im1 = ax1.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto', origin='lower',
                         extent=[self.current_coords[0].min(), self.current_coords[0].max(),
                                 self.current_coords[1].min(), self.current_coords[1].max()])
        ax1.set_title(f"G-S Alignment Depth Map ({self.current_depth_map.shape[1]}x{self.current_depth_map.shape[0]})")
        ax1.set_xlabel("S_x (Projection Plane)")
        ax1.set_ylabel("S_y (Projection Plane)")
        
        # Nuit radius from GUI for overlay (contextual)
        nuit_r_display = self.nuit_radius.get()
        circle = plt.Circle((0, 0), nuit_r_display, fill=False, color='cyan', linewidth=1, linestyle=':', alpha=0.9, label=f'Nuit Radius: {nuit_r_display}')
        ax1.add_patch(circle)
        
        perfect_alignments_scatter = [a for a in alignments_for_scatter if a['dist_boundary'] < 0.001]
        if perfect_alignments_scatter:
            perfect_x = [a['S_x'] for a in perfect_alignments_scatter]
            perfect_y = [a['S_y'] for a in perfect_alignments_scatter]
            ax1.scatter(perfect_x, perfect_y, c='red', s=20, marker='*', 
                       label=f'Boundary Alignments ({len(perfect_alignments_scatter)})', alpha=0.7)
        
        ax1.legend(fontsize='small')
        self.fig.colorbar(im1, ax=ax1, label='Depth (Orthogonal G_refl component)')
        
        ax2 = self.fig.add_subplot(gs_gridspec[1, 0])
        conditions = {}
        for a in alignments_for_scatter: # Use the passed full list for stats
            cond = a['condition'] if a['condition'] else 'Unknown'
            conditions[cond] = conditions.get(cond, 0) + 1
        
        if conditions:
            cond_names = list(conditions.keys())
            cond_counts = list(conditions.values())
            ax2.pie(cond_counts, labels=[name.replace(" PROJECTION", "").replace(", NUIT RADIUS = "," R=") for name in cond_names], 
                    autopct='%1.1f%%', textprops={'fontsize': 8})
            ax2.set_title("Alignments by Condition", fontsize=10)
        
        ax3 = self.fig.add_subplot(gs_gridspec[1, 1])
        if self.current_depth_map.size > 0 : # Check if depth map is not empty
            ax3.hist(self.current_depth_map[self.current_depth_map != 0].flatten(), bins=50, alpha=0.7, color='blue') # Exclude zeros if they mean no data
        ax3.set_xlabel("Depth Value", fontsize=9)
        ax3.set_ylabel("Pixel Count", fontsize=9)
        ax3.set_title("Depth Distribution (Non-zero)", fontsize=10)
        ax3.tick_params(axis='both', which='major', labelsize=8)

        self.canvas.draw()

    def select_alignment_condition(self):
        if not hasattr(self, 'alignment_data') or not self.alignment_data:
            messagebox.showwarning("No Data", "Please load alignment data first")
            return
        
        unique_conditions = sorted(list(set(a['condition'] for a in self.alignment_data if a['condition'])))
        
        if not unique_conditions:
            messagebox.showwarning("No Conditions", "No condition data found in alignment file")
            return
        
        selection_window = tk.Toplevel(self.root)
        selection_window.title("Select Alignment Conditions")
        selection_window.geometry("450x400") # Adjusted size
        
        ttk.Label(selection_window, text="Select conditions to include for Depth Map:").pack(pady=10)
        
        condition_vars = {}
        listbox_frame = ttk.Frame(selection_window)
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        listbox = tk.Listbox(listbox_frame, selectmode=tk.MULTIPLE, exportselection=False)
        for condition in unique_conditions:
            listbox.insert(tk.END, condition)
            listbox.select_set(tk.END) # Select all by default
        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=listbox.yview)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        def apply_selection():
            selected_indices = listbox.curselection()
            selected_conditions = [listbox.get(i) for i in selected_indices]
            
            if selected_conditions:
                filtered_alignments = [a for a in self.alignment_data if a['condition'] in selected_conditions]
                if filtered_alignments:
                    self.create_depth_map_from_alignments(filtered_alignments) # This uses geometric depth
                else:
                    messagebox.showwarning("No Data", "No alignments match the selected conditions.")
                    self.current_depth_map = None # Clear map
                    self.show_empty_plot()
                selection_window.destroy()
            else:
                messagebox.showwarning("No Selection", "Please select at least one condition")
        
        button_panel = ttk.Frame(selection_window)
        button_panel.pack(pady=10)
        ttk.Button(button_panel, text="Apply", command=apply_selection).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_panel, text="Cancel", command=selection_window.destroy).pack(side=tk.LEFT, padx=5)
    
    def show_loaded_image(self):
        if self.image_data is not None:
            self.fig.clear()
            ax = self.fig.add_subplot(111)
            ax.imshow(self.image_data)
            ax.set_title(f"Loaded Image: {self.image_data.shape[1]}x{self.image_data.shape[0]} pixels")
            ax.axis('off')
            self.canvas.draw()
    
    def cancel_processing(self):
        self.processing_cancelled = True
        self.process_status_label.config(text="Cancelling...", foreground="orange")
    
    def process_image_to_depth_map(self):
        if self.image_data is None:
            messagebox.showwarning("No Image", "Please load an image first")
            return
        try:
            self.processing_cancelled = False
            self.process_button.config(state="disabled")
            self.cancel_button.config(state="normal")
            method = self.depth_method.get()
            depth_scale_param = self.depth_scale.get()
            depth_contrast_param = self.depth_contrast.get()
            self.progress_var.set(0)
            self.root.update_idletasks()
            start_time = time.time()
            
            depth_map_raw = self.create_depth_from_image(self.image_data, method) # Removed scale/contrast here
            
            if self.processing_cancelled:
                self.process_status_label.config(text="Processing cancelled", foreground="orange")
                return

            # Apply scaling and contrast AFTER the method-specific calculation
            # This ensures gs_coordinate_geometric returns values in [0,1] before these generic adjustments
            depth_map_adjusted = depth_map_raw * depth_scale_param
            depth_map_final = np.power(np.clip(depth_map_adjusted, 0, depth_map_adjusted.max() if depth_map_adjusted.max() > 0 else 1.0), depth_contrast_param)


            processing_time = time.time() - start_time
            self.current_depth_map = depth_map_final
            height, width = depth_map_final.shape
            x = np.linspace(0, width-1, width)
            y = np.linspace(0, height-1, height)
            self.current_coords = np.meshgrid(x, y)
            
            debug_text = (f"Method: {method}\nProcessing time: {processing_time:.2f}s\n"
                          f"Raw Depth Range: [{depth_map_raw.min():.4f}, {depth_map_raw.max():.4f}]\n"
                          f"Final Depth Range: [{depth_map_final.min():.4f}, {depth_map_final.max():.4f}]\n"
                          f"Non-zero raw: {np.count_nonzero(depth_map_raw)}/{depth_map_raw.size}")
            self.debug_label.config(text=debug_text)
            
            self.process_status_label.config(
                text=f"âœ… Processed using {method} in {processing_time:.2f}s", foreground="green"
            )
            self.update_viz_button.config(state="normal")
            self.export_button.config(state="normal")
            self.visualize_depth_map()
            messagebox.showinfo("Success", f"Image processed to depth map using {method} in {processing_time:.2f} seconds")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process image: {str(e)}")
        finally:
            self.process_button.config(state="normal")
            self.cancel_button.config(state="disabled")
            self.progress_var.set(0)
    
    def create_depth_from_image(self, image_data, method): # Removed scale/contrast params
        image_float = image_data.astype(np.float32) / 255.0
        depth = np.zeros((image_float.shape[0], image_float.shape[1]), dtype=np.float32)

        if method == "luminosity":
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        elif method == "rgb_magnitude":
            depth = np.sqrt(image_float[:,:,0]**2 + image_float[:,:,1]**2 + image_float[:,:,2]**2) / np.sqrt(3)
        elif method == "saturation":
            max_color = np.max(image_float, axis=2)
            min_color = np.min(image_float, axis=2)
            # Add epsilon to prevent division by zero for black pixels
            depth = np.where(max_color > 1e-6, (max_color - min_color) / (max_color + 1e-6), 0)
        elif method == "edges":
            gray = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
            gray_uint8 = (gray * 255).astype(np.uint8)
            edges = cv2.Canny(gray_uint8, 50, 150)
            depth = edges.astype(np.float32) / 255.0
        elif method == "gs_coordinate_geometric": # Updated method name
            if self.full_sampling.get():
                depth = self._create_gs_depth_geometric_full_sampling(image_float)
            else:
                depth = self._create_gs_depth_geometric_sparse(image_float)
        else: # Default to luminosity
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        
        # Ensure depth is in a reasonable range, e.g., [0,1] if it's a direct geometric interpretation
        # The generic scaling/contrast will be applied outside this function.
        if depth.max() > depth.min(): # Avoid division by zero if flat
             if method == "gs_coordinate_geometric": # Should already be [0,1]
                 pass # Values are sqrt(1-...)
             else: # Normalize other methods to [0,1] before generic scale/contrast
                 depth = (depth - depth.min()) / (depth.max() - depth.min())
        else:
            depth = np.zeros_like(depth)


        return depth

    def _calculate_s_coord_from_g_unit_and_hadit(self, g_unit_vector, hadit_3d_vector):
        """
        Calculates the S-coordinate based on a unit G-vector and a Hadit vector.
        This S-coordinate is assumed to be the 2D projection of the unit G-vector after
        interaction with the Hadit field, onto an XY-like plane.
        """
        g_theta_rad = np.arctan2(g_unit_vector[1], g_unit_vector[0])
        # Clip argument to arccos to prevent NaN due to potential floating point inaccuracies
        g_phi_arg = np.clip(g_unit_vector[2], -1.0, 1.0)
        g_phi_rad = np.arccos(g_phi_arg)

        # G projection components (from unit G vector)
        g_proj_x = np.sin(g_phi_rad) * np.cos(g_theta_rad)
        g_proj_y = np.sin(g_phi_rad) * np.sin(g_theta_rad)

        # Hadit vector processing
        hadit_mag = np.linalg.norm(hadit_3d_vector)
        if hadit_mag < 1e-8: # If Hadit vector is (near) zero
            h_proj_x_term = 0.0
            h_proj_y_term = 0.0
        else:
            hadit_unit = hadit_3d_vector / hadit_mag
            hadit_theta_rad = np.arctan2(hadit_unit[1], hadit_unit[0])
            hadit_phi_arg = np.clip(hadit_unit[2], -1.0, 1.0)
            hadit_phi_rad = np.arccos(hadit_phi_arg)

            # Original Hadit projection components (scaled by hadit_mag)
            # These represent the Hadit vector's projection, which then influences S
            hadit_proj_x_orig = hadit_mag * np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad)
            hadit_proj_y_orig = hadit_mag * np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad)
            
            delta_theta = g_theta_rad - hadit_theta_rad
            # These terms are from the user's original S-coordinate formulation
            h_proj_x_term = hadit_proj_x_orig * np.cos(delta_theta)
            h_proj_y_term = hadit_proj_y_orig * np.sin(delta_theta)

        # S-coordinate calculation, based on the structure of the user's original formula
        s_x = g_proj_x - h_proj_x_term
        s_y = g_proj_y - h_proj_y_term
        
        return np.array([s_x, s_y])

    def _create_gs_depth_geometric_full_sampling(self, image_float):
        height, width, _ = image_float.shape
        depth_map = np.zeros((height, width), dtype=np.float32)

        hadit_theta_rad = np.radians(self.hadit_theta.get())
        hadit_phi_rad = np.radians(self.hadit_phi.get())
        hadit_3d = np.array([
            np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad),
            np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad),
            np.cos(hadit_phi_rad)
        ])
        
        # Sphere radius for G_refl, typically 1.0 for unit sphere.
        # gs_scale could be used here if it represents this radius.
        # For now, assuming unit sphere as G_refl in alignment data are unit.
        sphere_radius_sq = self.gs_scale.get()**2 # Using gs_scale as R_sphere

        print(f"G-S Geometric Depth (Full Sampling): Hadit={hadit_3d}, Sphere_R^2={sphere_radius_sq}")

        for y in range(height):
            for x in range(width):
                if self.processing_cancelled: return np.zeros((height, width))
                rgb_vector = image_float[y, x]
                g_magnitude = np.linalg.norm(rgb_vector)
                
                if g_magnitude < 1e-8:
                    depth_map[y, x] = 0.0 # Or sphere_radius if 'empty' is full depth
                    continue
                
                g_unit = rgb_vector / g_magnitude
                s_coord = self._calculate_s_coord_from_g_unit_and_hadit(g_unit, hadit_3d)
                
                # s_coord is (sx, sy) - the 2D projection. Depth is the orthogonal component.
                # Assuming s_coord are the first two components of a point on the sphere.
                val_inside_sqrt = sphere_radius_sq - (s_coord[0]**2 + s_coord[1]**2)
                
                if val_inside_sqrt >= 0:
                    depth_map[y, x] = np.sqrt(val_inside_sqrt)
                else:
                    depth_map[y, x] = 0.0 # Projected point is outside the sphere's projection circle
            
            if y % (height // 20) == 0: # More frequent updates
                self.progress_var.set((y / height) * 100)
                self.root.update_idletasks()
        
        self.progress_var.set(100)
        return depth_map

    def _create_gs_depth_geometric_sparse(self, image_float):
        height, width, _ = image_float.shape
        depth_map = np.zeros((height, width), dtype=np.float32)

        hadit_theta_rad = np.radians(self.hadit_theta.get())
        hadit_phi_rad = np.radians(self.hadit_phi.get())
        hadit_3d = np.array([
            np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad),
            np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad),
            np.cos(hadit_phi_rad)
        ])
        sphere_radius_sq = self.gs_scale.get()**2

        print(f"G-S Geometric Depth (Sparse Sampling): Hadit={hadit_3d}, Sphere_R^2={sphere_radius_sq}")
        
        sample_rate = max(1, min(height//50, width//50, 10)) # Cap sample rate for speed
        
        num_steps = (height // sample_rate)
        current_step = 0

        for y_start_block in range(0, height, sample_rate):
            if self.processing_cancelled: return np.zeros((height, width))
            for x_start_block in range(0, width, sample_rate):
                # Process the corner pixel of the block
                y = y_start_block
                x = x_start_block 
                
                rgb_vector = image_float[y, x]
                g_magnitude = np.linalg.norm(rgb_vector)
                depth_value = 0.0

                if g_magnitude >= 1e-8:
                    g_unit = rgb_vector / g_magnitude
                    s_coord = self._calculate_s_coord_from_g_unit_and_hadit(g_unit, hadit_3d)
                    val_inside_sqrt = sphere_radius_sq - (s_coord[0]**2 + s_coord[1]**2)
                    if val_inside_sqrt >= 0:
                        depth_value = np.sqrt(val_inside_sqrt)
                
                # Fill the block
                y_end_block = min(height, y_start_block + sample_rate)
                x_end_block = min(width, x_start_block + sample_rate)
                depth_map[y_start_block:y_end_block, x_start_block:x_end_block] = depth_value
            
            current_step +=1
            if num_steps > 0 :
                 self.progress_var.set((current_step / num_steps) * 100)
                 self.root.update_idletasks()
        
        self.progress_var.set(100)
        return depth_map
    
    # Old methods calculate_s_coordinate and calculate_alignment_depth are now unused
    # by the "gs_coordinate_geometric" method. They are kept in case other parts
    # or future methods might use them or for reference.

    def calculate_s_coordinate(self, rgb_vector, hadit_vector): # Original, now potentially unused by gs_geometric
        g_magnitude = np.linalg.norm(rgb_vector)
        if g_magnitude < 1e-8: return np.array([0.0, 0.0])
        g_unit = rgb_vector / g_magnitude
        g_theta = np.arctan2(g_unit[1], g_unit[0])
        g_phi_arg = np.clip(g_unit[2], -1.0, 1.0)
        g_phi = np.arccos(g_phi_arg)
        
        hadit_magnitude = np.linalg.norm(hadit_vector)
        if hadit_magnitude < 1e-8:
            hadit_unit = np.array([0.0,0.0,0.0]) # Or handle appropriately
            hadit_theta = 0.0
            hadit_phi = np.pi/2 # Avoid NaN, effectively making projection terms zero if mag is zero
        else:
            hadit_unit = hadit_vector / hadit_magnitude
            hadit_theta = np.arctan2(hadit_unit[1], hadit_unit[0])
            hadit_phi_arg = np.clip(hadit_unit[2], -1.0, 1.0)
            hadit_phi = np.arccos(hadit_phi_arg)
        
        g_proj_x = g_magnitude * np.sin(g_phi) * np.cos(g_theta)
        g_proj_y = g_magnitude * np.sin(g_phi) * np.sin(g_theta)
        
        hadit_proj_x_orig = hadit_magnitude * np.sin(hadit_phi) * np.cos(hadit_theta)
        hadit_proj_y_orig = hadit_magnitude * np.sin(hadit_phi) * np.sin(hadit_theta)
        
        delta_theta = g_theta - hadit_theta
        s_x = g_proj_x - hadit_proj_x_orig * np.cos(delta_theta)
        s_y = g_proj_y - hadit_proj_y_orig * np.sin(delta_theta) # This was the original structure
        
        return np.array([s_x, s_y])

    def calculate_alignment_depth(self, s_coordinate, nuit_radius=0.5): # Original, now unused by gs_geometric
        dist_origin = np.linalg.norm(s_coordinate)
        dist_boundary = abs(dist_origin - nuit_radius)
        
        if dist_boundary < 0.001: return 1.0
        elif dist_origin <= nuit_radius: return 0.8 + 0.2 / (1.0 + dist_boundary * 10)
        else: return 0.5 / (1.0 + dist_boundary)

    def test_gs_method(self):
        size = 256
        test_image = np.zeros((size, size, 3), dtype=np.float32)
        for y in range(size):
            for x in range(size):
                center_x, center_y = size // 2, size // 2
                distance = np.sqrt((x - center_x)**2 + (y - center_y)**2)
                normalized_distance = np.clip(distance / (size // 2), 0, 1)
                test_image[y, x, 0] = np.sin(x / size * np.pi * 2) * 0.5 + 0.5
                test_image[y, x, 1] = np.cos(y / size * np.pi * 2) * 0.5 + 0.5
                test_image[y, x, 2] = 1.0 - normalized_distance
        
        self.image_data = (np.clip(test_image, 0, 1) * 255).astype(np.uint8)
        self.loaded_image = Image.fromarray(self.image_data)
        self.image_status_label.config(text=f"âœ… Test pattern created ({size}x{size})", foreground="green")
        self.process_button.config(state="normal")
        self.process_status_label.config(text="Test pattern ready for G-S Geometric Depth", foreground="blue")
        self.show_loaded_image()
        self.depth_method.set("gs_coordinate_geometric") # Select the new method
        self.full_sampling.set(True)
        messagebox.showinfo("Test Pattern", "Synthetic pattern loaded for G-S Geometric Depth testing.")
    
    def visualize_depth_map(self):
        if self.current_depth_map is None: return
        self.fig.clear()
        
        method_title_name = self.depth_method.get()
        if method_title_name == "gs_coordinate_geometric":
            method_title_name = "G-S Geometric Depth"

        sampling_mode = "Full" if self.full_sampling.get() else "Sparse"
        title_suffix = f" ({method_title_name} - {sampling_mode})" if "G-S" in method_title_name else f" ({method_title_name})"

        if self.image_data is not None:
            ax1 = self.fig.add_subplot(131)
            ax1.imshow(self.image_data)
            ax1.set_title("Original Image")
            ax1.axis('off')
            
            ax2 = self.fig.add_subplot(132)
            im = ax2.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto')
            ax2.set_title(f"Depth Map{title_suffix}")
            ax2.axis('off')
            
            ax3 = self.fig.add_subplot(133)
            if self.current_depth_map.size > 0:
                 ax3.hist(self.current_depth_map.flatten(), bins=50, alpha=0.7, color='blue')
            ax3.set_xlabel("Depth Value")
            ax3.set_ylabel("Pixel Count")
            ax3.set_title(f"Depth Dist.\nRange: [{self.current_depth_map.min():.3f}, {self.current_depth_map.max():.3f}]")
            self.fig.colorbar(im, ax=ax2, label='Depth', shrink=0.6)
        else: # Should not happen if processing image, but for G-S alignment data path
            ax = self.fig.add_subplot(111)
            im = ax.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto')
            ax.set_title(f"Depth Map{title_suffix}")
            ax.axis('off')
            self.fig.colorbar(im, ax=ax, label='Depth', shrink=0.8)
        
        self.fig.tight_layout()
        self.canvas.draw()
    
    def update_visualization(self):
        if self.current_depth_map is not None:
            if hasattr(self, 'alignment_data') and self.alignment_data and not self.image_data: # If only alignment data is loaded
                self.visualize_gs_alignment_depth_map(self.alignment_data)
            else: # If image data (and potentially depth map from it) is present
                self.visualize_depth_map()
        else:
            self.show_empty_plot() # Or some other placeholder
    
    def export_depth_map(self):
        if self.current_depth_map is None:
            messagebox.showwarning("No Depth Map", "Please process data first")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Save Depth Map As",
            defaultextension=".png",
            filetypes=[
                ("PNG image", "*.png"), 
                ("NumPy array", "*.npy"),
                ("CSV file", "*.csv"),
                ("All files", "*.*")
            ]
        )
        if not filename: return

        try:
            file_ext = os.path.splitext(filename)[1].lower()
            if file_ext == ".png":
                # Normalize to 0-255 for image saving
                depth_norm = self.current_depth_map
                if depth_norm.max() > depth_norm.min():
                    depth_norm = (depth_norm - depth_norm.min()) / (depth_norm.max() - depth_norm.min())
                
                # Apply colormap if user wants colored PNG, or save grayscale
                # For simplicity, save as grayscale for now. User can apply colormap in viewer.
                img_array = (depth_norm * 255).astype(np.uint8)
                img = Image.fromarray(img_array, mode='L') # Grayscale
                img.save(filename)
                messagebox.showinfo("Export Success", f"Depth map saved as PNG: {filename}")
            elif file_ext == ".npy":
                np.save(filename, self.current_depth_map)
                messagebox.showinfo("Export Success", f"Depth map saved as NPY: {filename}")
            elif file_ext == ".csv":
                np.savetxt(filename, self.current_depth_map, delimiter=",")
                messagebox.showinfo("Export Success", f"Depth map saved as CSV: {filename}")
            else:
                messagebox.showerror("Unsupported Format", "Please choose .png, .npy, or .csv")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export depth map: {str(e)}")

    def load_sample_data(self):
        """Loads a sample G-S alignment data file for quick testing."""
        # Create a dummy alignment file content
        dummy_content = """
S-NUIT ALIGNMENT DATA EXPORT
==================================================
Generated: 2025-06-08 10:00:00
Total alignments found: 10

SUMMARY BY CONDITION:
------------------------------
XY PROJECTION, NUIT RADIUS = 0.5: 5 alignments
XZ PROJECTION, NUIT RADIUS = 0.5: 5 alignments

================================================================================
CONDITION: XY PROJECTION, NUIT RADIUS = 0.5
================================================================================
Number of alignments: 5
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
0.00,10.00,0.00,20.00,-0.500,0.000,0.000,0.500,-0.500,0.000,-0.866
0.00,10.00,20.00,20.00,-0.400,0.200,0.053,0.447,-0.400,0.200,-0.894
10.00,20.00,30.00,40.00,-0.300,-0.300,0.076,0.424,-0.300,-0.300,-0.900
20.00,30.00,40.00,50.00,0.100,0.450,0.039,0.461,0.100,0.450,-0.887
30.00,40.00,50.00,60.00,0.400,0.250,0.029,0.471,0.400,0.250,-0.883
================================================================================
CONDITION: XZ PROJECTION, NUIT RADIUS = 0.5
================================================================================
Number of alignments: 5
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
0.00,90.00,0.00,0.00,0.000,0.500,0.000,0.500,0.000,-0.866,0.500
10.00,80.00,10.00,10.00,0.100,0.400,0.088,0.412,0.100,-0.900,0.400
20.00,70.00,20.00,20.00,0.200,0.300,0.139,0.361,0.200,-0.850,0.300
30.00,60.00,30.00,30.00,-0.100,-0.450,0.039,0.461,-0.100,-0.887,-0.450
40.00,50.00,40.00,40.00,-0.200,-0.350,0.097,0.403,-0.200,-0.800,-0.350
"""
        # Use a temporary file to simulate loading
        import tempfile
        temp_file = tempfile.NamedTemporaryFile(mode="w+", delete=False, suffix=".txt")
        temp_file.write(dummy_content)
        temp_file_path = temp_file.name
        temp_file.close()

        try:
            self.parse_gs_alignment_file(temp_file_path)
            messagebox.showinfo("Sample Data", "Sample G-S alignment data loaded.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load sample data: {e}")
        finally:
            if os.path.exists(temp_file_path):
                os.unlink(temp_file_path)

if __name__ == '__main__':
    root = tk.Tk()
    app = GSDepthMapperGUI(root)
    root.mainloop()
