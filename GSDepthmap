import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import cv2
import os
from PIL import Image, ImageTk
import time
from scipy.ndimage import gaussian_filter

class GSDepthMapperGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("G-S Alignment Depth Mapper - Fixed Quantum Method v5")
        self.root.geometry("1400x900")
        
        # Data storage
        self.alignment_data = []
        self.perfect_alignments = []
        self.current_depth_map = None
        self.current_coords = None
        self.loaded_image = None
        self.image_data = None
        
        # Default parameters
        self.resolution = tk.IntVar(value=256)
        self.colormap = tk.StringVar(value="viridis")
        self.nuit_radius = tk.DoubleVar(value=0.5)  # FIXED: Added Nuit radius parameter
        
        # Image processing parameters
        self.hadit_theta = tk.DoubleVar(value=45.0)
        self.hadit_phi = tk.DoubleVar(value=60.0)
        self.depth_method = tk.StringVar(value="luminosity")
        self.depth_scale = tk.DoubleVar(value=1.0)
        self.depth_contrast = tk.DoubleVar(value=1.0)
        self.gs_scale = tk.DoubleVar(value=1.0)
        
        # Full sampling control
        self.full_sampling = tk.BooleanVar(value=True)
        self.processing_cancelled = False
        
        self.setup_gui()
        
    def setup_gui(self):
        """Setup the main GUI layout."""
        # Create main frames
        control_container = ttk.Frame(self.root)
        control_container.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
        
        viz_frame = ttk.Frame(self.root)
        viz_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.setup_scrollable_control_panel(control_container)
        self.setup_visualization_panel(viz_frame)
        
    def setup_scrollable_control_panel(self, parent):
        """Setup a scrollable control panel."""
        # Create canvas and scrollbar for scrolling
        canvas = tk.Canvas(parent, width=350, highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        # Configure scrolling
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        # Pack scrollbar and canvas
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        # Bind mousewheel to canvas for scrolling
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        def _bind_to_mousewheel(event):
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        def _unbind_from_mousewheel(event):
            canvas.unbind_all("<MouseWheel>")
        
        canvas.bind('<Enter>', _bind_to_mousewheel)
        canvas.bind('<Leave>', _unbind_from_mousewheel)
        
        # Now setup the actual control panel content in the scrollable frame
        self.setup_control_panel(scrollable_frame)
        
    def setup_control_panel(self, parent):
        """Setup the control panel content."""
        # Title
        title_label = ttk.Label(parent, text="G-S Depth Mapper", font=("Arial", 16, "bold"))
        title_label.pack(pady=(0, 20))
        
        # Step 1: Data Loading
        image_frame = ttk.LabelFrame(parent, text="Step 1: Load Data", padding=10)
        image_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(image_frame, text="ðŸ“ Load Image File", 
                  command=self.load_image, width=25).pack(fill=tk.X, pady=2)
        
        ttk.Button(image_frame, text="ðŸ“Š Load G-S Alignment Data", 
                  command=self.load_alignment_data, width=25).pack(fill=tk.X, pady=2)
        
        self.image_status_label = ttk.Label(image_frame, text="No data loaded", foreground="red")
        self.image_status_label.pack(pady=5)
        
        # Step 2: Processing Parameters
        params_frame = ttk.LabelFrame(parent, text="Step 2: Processing Parameters", padding=10)
        params_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Depth method
        ttk.Label(params_frame, text="Depth Method:").pack(anchor=tk.W)
        methods = [
            ("Luminosity (Brightness)", "luminosity"),
            ("RGB Magnitude", "rgb_magnitude"),
            ("Saturation", "saturation"),
            ("G-S Coordinate (FIXED)", "gs_coordinate"),
            ("Edge Detection", "edges")
        ]
        
        for text, value in methods:
            ttk.Radiobutton(params_frame, text=text, variable=self.depth_method, 
                           value=value).pack(anchor=tk.W)
        
        # Depth scale
        ttk.Label(params_frame, text="Depth Scale:").pack(anchor=tk.W, pady=(10, 0))
        scale_frame = ttk.Frame(params_frame)
        scale_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(scale_frame, from_=0.1, to=5.0, variable=self.depth_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(scale_frame, textvariable=self.depth_scale, width=8).pack(side=tk.RIGHT)
        
        # Depth contrast
        ttk.Label(params_frame, text="Depth Contrast:").pack(anchor=tk.W, pady=(10, 0))
        contrast_frame = ttk.Frame(params_frame)
        contrast_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(contrast_frame, from_=0.1, to=3.0, variable=self.depth_contrast, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(contrast_frame, textvariable=self.depth_contrast, width=8).pack(side=tk.RIGHT)
        
        # G-S specific parameters
        gs_frame = ttk.LabelFrame(params_frame, text="G-S Parameters (FIXED Quantum Method)", padding=5)
        gs_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Checkbutton(gs_frame, text="Full pixel sampling (higher quality, slower)", 
                       variable=self.full_sampling).pack(anchor=tk.W, pady=(0, 5))
        
        ttk.Label(gs_frame, text="Hadit Î¸ (degrees):").pack(anchor=tk.W)
        theta_frame = ttk.Frame(gs_frame)
        theta_frame.pack(fill=tk.X)
        ttk.Scale(theta_frame, from_=0, to=360, variable=self.hadit_theta, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(theta_frame, textvariable=self.hadit_theta, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="Hadit Ï† (degrees):").pack(anchor=tk.W)
        phi_frame = ttk.Frame(gs_frame)
        phi_frame.pack(fill=tk.X)
        ttk.Scale(phi_frame, from_=0, to=180, variable=self.hadit_phi, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(phi_frame, textvariable=self.hadit_phi, width=8).pack(side=tk.RIGHT)
        
        # FIXED: Added Nuit radius control
        ttk.Label(gs_frame, text="Nuit Radius:").pack(anchor=tk.W)
        nuit_frame = ttk.Frame(gs_frame)
        nuit_frame.pack(fill=tk.X)
        ttk.Scale(nuit_frame, from_=0.1, to=2.0, variable=self.nuit_radius, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(nuit_frame, textvariable=self.nuit_radius, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="G-S Scale Factor:").pack(anchor=tk.W)
        gs_scale_frame = ttk.Frame(gs_frame)
        gs_scale_frame.pack(fill=tk.X)
        ttk.Scale(gs_scale_frame, from_=0.1, to=10.0, variable=self.gs_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(gs_scale_frame, textvariable=self.gs_scale, width=8).pack(side=tk.RIGHT)
        
        # Step 3: Process Image
        process_frame = ttk.LabelFrame(parent, text="Step 3: Process Image", padding=10)
        process_frame.pack(fill=tk.X, pady=(0, 10))
        
        # Processing buttons frame
        button_frame = ttk.Frame(process_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.process_button = ttk.Button(button_frame, text="ðŸ”„ Process Image to Depth Map", 
                                        command=self.process_image_to_depth_map, 
                                        width=20, state="disabled")
        self.process_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        
        self.cancel_button = ttk.Button(button_frame, text="âŒ Cancel", 
                                       command=self.cancel_processing, 
                                       width=8, state="disabled")
        self.cancel_button.pack(side=tk.RIGHT)
        
        self.process_status_label = ttk.Label(process_frame, text="Load data first", foreground="orange")
        self.process_status_label.pack(pady=5)
        
        # Progress bar
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(process_frame, variable=self.progress_var, 
                                          maximum=100, length=300)
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        # Step 4: Visualization
        viz_frame_control = ttk.LabelFrame(parent, text="Step 4: Visualization", padding=10)
        viz_frame_control.pack(fill=tk.X, pady=(0, 10))
        
        # Resolution
        ttk.Label(viz_frame_control, text="Resolution:").pack(anchor=tk.W)
        resolution_frame = ttk.Frame(viz_frame_control)
        resolution_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(resolution_frame, from_=64, to=1024, variable=self.resolution, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(resolution_frame, textvariable=self.resolution, width=5).pack(side=tk.RIGHT)
        
        # Colormap
        ttk.Label(viz_frame_control, text="Colormap:").pack(anchor=tk.W, pady=(10, 0))
        colormap_combo = ttk.Combobox(viz_frame_control, textvariable=self.colormap, 
                                     values=["viridis", "plasma", "hot", "coolwarm", 
                                            "jet", "terrain", "ocean", "rainbow", "gray"])
        colormap_combo.pack(fill=tk.X, pady=2)
        
        # Update visualization button
        self.update_viz_button = ttk.Button(viz_frame_control, text="ðŸŽ¨ Update Visualization", 
                                           command=self.update_visualization, 
                                           state="disabled")
        self.update_viz_button.pack(fill=tk.X, pady=5)
        
        # Condition selection button
        self.select_condition_button = ttk.Button(viz_frame_control, text="ðŸŽ›ï¸ Select Conditions", 
                                                 command=self.select_alignment_condition, 
                                                 state="disabled")
        self.select_condition_button.pack(fill=tk.X, pady=2)
        
        # Debug info
        debug_frame = ttk.LabelFrame(viz_frame_control, text="Debug Info", padding=5)
        debug_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.debug_label = ttk.Label(debug_frame, text="No processing done yet", font=("Courier", 8))
        self.debug_label.pack(fill=tk.X)
        
        # Step 5: Export
        export_frame = ttk.LabelFrame(parent, text="Step 5: Export", padding=10)
        export_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.export_button = ttk.Button(export_frame, text="ðŸ’¾ Export Depth Map", 
                                       command=self.export_depth_map, 
                                       state="disabled")
        self.export_button.pack(fill=tk.X, pady=2)
        
        # Quick actions
        quick_frame = ttk.LabelFrame(parent, text="Quick Test", padding=10)
        quick_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(quick_frame, text="ðŸ§ª Load Sample Data", 
                  command=self.load_sample_data).pack(fill=tk.X, pady=2)
        
        ttk.Button(quick_frame, text="ðŸŽ¯ Test G-S Method", 
                  command=self.test_gs_method).pack(fill=tk.X, pady=2)
        
        # Add some bottom padding to ensure everything is visible
        ttk.Label(parent, text=" ").pack(pady=20)
        
    def setup_visualization_panel(self, parent):
        """Setup the visualization panel."""
        # Create matplotlib figure
        self.fig = Figure(figsize=(12, 10), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.fig, parent)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Add toolbar
        toolbar_frame = ttk.Frame(parent)
        toolbar_frame.pack(fill=tk.X)
        
        from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
        toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
        toolbar.update()
        
        # Initial empty plot
        self.show_empty_plot()
    
    def show_empty_plot(self):
        """Show empty plot with instructions."""
        self.fig.clear()
        ax = self.fig.add_subplot(111)
        ax.text(0.5, 0.5, "Load data to get started!\n\n1. Click 'Load Image File' or 'Load G-S Alignment Data'\n2. Adjust parameters if needed\n3. Click 'Process Image to Depth Map' (for images)\n4. Compare RGB vs FIXED G-S methods!", 
                ha='center', va='center', fontsize=14, transform=ax.transAxes)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_title("G-S Depth Mapper - FIXED Quantum Method (v5)")
        self.canvas.draw()
    
    def load_image(self):
        """Load an image file."""
        filename = filedialog.askopenfilename(
            title="Select Image File",
            filetypes=[
                ("Image files", "*.png *.jpg *.jpeg *.tiff *.tif *.bmp *.gif"),
                ("PNG files", "*.png"),
                ("JPEG files", "*.jpg *.jpeg"),
                ("TIFF files", "*.tiff *.tif"),
                ("All files", "*.*")
            ]
        )
        
        if filename:
            try:
                # Load image with PIL
                pil_image = Image.open(filename)
                
                # Convert to RGB if necessary
                if pil_image.mode != 'RGB':
                    pil_image = pil_image.convert('RGB')
                
                # Store original image
                self.loaded_image = pil_image
                
                # Convert to numpy array
                self.image_data = np.array(pil_image)
                
                # Update status
                self.image_status_label.config(
                    text=f"âœ… Loaded: {os.path.basename(filename)} ({self.image_data.shape[1]}x{self.image_data.shape[0]})",
                    foreground="green"
                )
                
                # Enable process button
                self.process_button.config(state="normal")
                self.process_status_label.config(text="Ready to process image", foreground="blue")
                
                # Show the loaded image
                self.show_loaded_image()
                
                messagebox.showinfo("Success", f"Image loaded: {os.path.basename(filename)}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load image: {str(e)}")
    
    def load_alignment_data(self):
        """Load G-S alignment data from text file."""
        filename = filedialog.askopenfilename(
            title="Select G-S Alignment Data File",
            filetypes=[
                ("Text files", "*.txt"),
                ("CSV files", "*.csv"),
                ("All files", "*.*")
            ]
        )
        
        if filename:
            try:
                self.parse_gs_alignment_file(filename)
                messagebox.showinfo("Success", f"G-S alignment data loaded from {os.path.basename(filename)}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load alignment data: {str(e)}")

    def parse_gs_alignment_file(self, filename):
        """Parse the G-S alignment data file format."""
        with open(filename, 'r') as f:
            content = f.read()
        
        # Extract summary information
        lines = content.split('\n')
        
        # Find total alignments
        total_alignments = 0
        for line in lines:
            if "Total alignments found:" in line:
                total_alignments = int(line.split(":")[1].strip())
                break
        
        # Parse each condition section
        all_alignments = []
        current_condition = None
        parsing_data = False
        
        for line in lines:
            line = line.strip()
            
            # Detect condition headers
            if "CONDITION:" in line and "PROJECTION" in line:
                current_condition = line.replace("CONDITION: ", "").strip()
                parsing_data = False
                continue
            
            # Start of detailed data section
            if line.startswith("G_theta_deg,G_phi_deg,Hadit_theta_deg"):
                parsing_data = True
                continue
            
            # Parse alignment data rows
            if parsing_data and line and not line.startswith("=") and "," in line:
                try:
                    parts = line.split(',')
                    if len(parts) >= 11:  # Ensure we have all expected columns
                        alignment = {
                            'condition': current_condition,
                            'G_theta': float(parts[0]),
                            'G_phi': float(parts[1]),
                            'Hadit_theta': float(parts[2]),
                            'Hadit_phi': float(parts[3]),
                            'S_x': float(parts[4]),
                            'S_y': float(parts[5]),
                            'dist_boundary': float(parts[6]),
                            'dist_origin': float(parts[7]),
                            'G_refl_x': float(parts[8]),
                            'G_refl_y': float(parts[9]),
                            'G_refl_z': float(parts[10])
                        }
                        all_alignments.append(alignment)
                except (ValueError, IndexError):
                    continue  # Skip malformed lines
            
            # Stop parsing data if we hit another section
            if parsing_data and line.startswith("="):
                parsing_data = False
        
        # Store the alignment data
        self.alignment_data = all_alignments
        
        # Create depth map from alignment data
        self.create_depth_map_from_alignments(all_alignments)
        
        # Update status
        self.image_status_label.config(
            text=f"âœ… G-S alignment data loaded: {len(all_alignments)} alignments",
            foreground="green"
        )
        
        # Enable condition selection button
        self.select_condition_button.config(state="normal")
        
        print(f"Loaded {len(all_alignments)} G-S alignments from {total_alignments} total")

    def create_depth_map_from_alignments(self, alignments, grid_size=512):
        """Create depth map from G-S alignment data."""
        if not alignments:
            return
        
        # Extract S coordinates and values
        s_x_coords = [a['S_x'] for a in alignments]
        s_y_coords = [a['S_y'] for a in alignments]
        
        # Choose depth value - you can experiment with different metrics
        depth_values = [1.0 / (a['dist_boundary'] + 0.001) for a in alignments]  # Inverse distance to boundary
        
        # Find coordinate ranges
        x_min, x_max = min(s_x_coords), max(s_x_coords)
        y_min, y_max = min(s_y_coords), max(s_y_coords)
        
        print(f"S coordinate ranges: X[{x_min:.3f}, {x_max:.3f}], Y[{y_min:.3f}, {y_max:.3f}]")
        
        # Create depth map grid
        depth_map = np.zeros((grid_size, grid_size))
        count_map = np.zeros((grid_size, grid_size))  # For averaging multiple points
        
        # Map coordinates to grid
        for i, (sx, sy, depth) in enumerate(zip(s_x_coords, s_y_coords, depth_values)):
            # Convert to grid coordinates
            if x_max > x_min:
                grid_x = int((sx - x_min) / (x_max - x_min) * (grid_size - 1))
            else:
                grid_x = grid_size // 2
                
            if y_max > y_min:
                grid_y = int((sy - y_min) / (y_max - y_min) * (grid_size - 1))
            else:
                grid_y = grid_size // 2
            
            # Ensure within bounds
            grid_x = max(0, min(grid_size - 1, grid_x))
            grid_y = max(0, min(grid_size - 1, grid_y))
            
            # Accumulate depth values (for averaging)
            depth_map[grid_y, grid_x] += depth
            count_map[grid_y, grid_x] += 1
        
        # Average overlapping points
        valid_mask = count_map > 0
        depth_map[valid_mask] /= count_map[valid_mask]
        
        # Apply Gaussian smoothing to fill gaps and smooth the surface
        smoothed_depth = gaussian_filter(depth_map, sigma=2.0)
        
        # Blend original and smoothed for better results
        final_depth = np.where(valid_mask, 
                              0.7 * depth_map + 0.3 * smoothed_depth,  # Original points get more weight
                              smoothed_depth)  # Empty areas use smoothed
        
        # Normalize
        if final_depth.max() > 0:
            final_depth = final_depth / final_depth.max()
        
        # Store the depth map
        self.current_depth_map = final_depth
        height, width = final_depth.shape
        x = np.linspace(x_min, x_max, width)
        y = np.linspace(y_min, y_max, height)
        self.current_coords = np.meshgrid(x, y)
        
        # Enable buttons
        self.update_viz_button.config(state="normal")
        self.export_button.config(state="normal")
        
        # Update status
        self.process_status_label.config(text="âœ… G-S alignment depth map created", foreground="green")
        
        # Debug info
        unique_points = np.count_nonzero(valid_mask)
        debug_text = f"G-S Alignment Data\nTotal alignments: {len(alignments)}\nUnique grid points: {unique_points}\nDepth range: [{final_depth.min():.4f}, {final_depth.max():.4f}]"
        self.debug_label.config(text=debug_text)
        
        # Visualize
        self.visualize_gs_alignment_depth_map(alignments)

    def visualize_gs_alignment_depth_map(self, alignments):
        """Visualize the G-S alignment depth map with analysis."""
        if self.current_depth_map is None:
            return
        
        self.fig.clear()
        
        # Create subplots for detailed analysis
        gs = self.fig.add_gridspec(2, 2, hspace=0.3, wspace=0.3)
        
        # Main depth map
        ax1 = self.fig.add_subplot(gs[0, :])
        im1 = ax1.imshow(self.current_depth_map, cmap=self.colormap.get(), 
                         extent=[self.current_coords[0].min(), self.current_coords[0].max(),
                                self.current_coords[1].min(), self.current_coords[1].max()])
        ax1.set_title(f"G-S Alignment Depth Map ({len(alignments)} alignments)")
        ax1.set_xlabel("S_x")
        ax1.set_ylabel("S_y")
        
        # Add Nuit boundary circle (radius 0.5 is common in your data)
        circle = plt.Circle((0, 0), 0.5, fill=False, color='red', linewidth=2, linestyle='--', alpha=0.7)
        ax1.add_patch(circle)
        
        # Mark perfect alignments (dist_boundary = 0)
        perfect_alignments = [a for a in alignments if a['dist_boundary'] < 0.001]
        if perfect_alignments:
            perfect_x = [a['S_x'] for a in perfect_alignments]
            perfect_y = [a['S_y'] for a in perfect_alignments]
            ax1.scatter(perfect_x, perfect_y, c='red', s=50, marker='*', 
                       label=f'Perfect Alignments ({len(perfect_alignments)})', alpha=0.8)
            ax1.legend()
        
        self.fig.colorbar(im1, ax=ax1, label='Alignment Intensity')
        
        # Condition distribution
        ax2 = self.fig.add_subplot(gs[1, 0])
        conditions = {}
        for a in alignments:
            cond = a['condition'] if a['condition'] else 'Unknown'
            conditions[cond] = conditions.get(cond, 0) + 1
        
        if conditions:
            cond_names = list(conditions.keys())
            cond_counts = list(conditions.values())
            ax2.pie(cond_counts, labels=cond_names, autopct='%1.1f%%')
            ax2.set_title("Alignments by Condition")
        
        # Distance distribution
        ax3 = self.fig.add_subplot(gs[1, 1])
        boundary_distances = [a['dist_boundary'] for a in alignments]
        ax3.hist(boundary_distances, bins=50, alpha=0.7, color='blue')
        ax3.set_xlabel("Distance to Boundary")
        ax3.set_ylabel("Count")
        ax3.set_title("Boundary Distance Distribution")
        ax3.axvline(x=0, color='red', linestyle='--', alpha=0.7, label='Perfect Alignment')
        ax3.legend()
        
        self.canvas.draw()

    def select_alignment_condition(self):
        """Allow user to select specific alignment conditions to visualize."""
        if not hasattr(self, 'alignment_data') or not self.alignment_data:
            messagebox.showwarning("No Data", "Please load alignment data first")
            return
        
        # Get unique conditions
        conditions = set(a['condition'] for a in self.alignment_data if a['condition'])
        
        if not conditions:
            messagebox.showwarning("No Conditions", "No condition data found in alignment file")
            return
        
        # Create selection dialog
        selection_window = tk.Toplevel(self.root)
        selection_window.title("Select Alignment Conditions")
        selection_window.geometry("400x300")
        
        ttk.Label(selection_window, text="Select conditions to include:").pack(pady=10)
        
        # Checkboxes for each condition
        condition_vars = {}
        for condition in sorted(conditions):
            var = tk.BooleanVar(value=True)
            ttk.Checkbutton(selection_window, text=condition, variable=var).pack(anchor='w', padx=20)
            condition_vars[condition] = var
        
        def apply_selection():
            selected_conditions = [cond for cond, var in condition_vars.items() if var.get()]
            if selected_conditions:
                filtered_alignments = [a for a in self.alignment_data if a['condition'] in selected_conditions]
                self.create_depth_map_from_alignments(filtered_alignments)
                selection_window.destroy()
            else:
                messagebox.showwarning("No Selection", "Please select at least one condition")
        
        ttk.Button(selection_window, text="Apply", command=apply_selection).pack(pady=20)
        ttk.Button(selection_window, text="Cancel", command=selection_window.destroy).pack()
    
    def show_loaded_image(self):
        """Show the loaded image."""
        if self.image_data is not None:
            self.fig.clear()
            ax = self.fig.add_subplot(111)
            ax.imshow(self.image_data)
            ax.set_title(f"Loaded Image: {self.image_data.shape[1]}x{self.image_data.shape[0]} pixels")
            ax.axis('off')
            self.canvas.draw()
    
    def cancel_processing(self):
        """Cancel the current processing operation."""
        self.processing_cancelled = True
        self.process_status_label.config(text="Cancelling...", foreground="orange")
    
    def process_image_to_depth_map(self):
        """Process the loaded image to create depth map."""
        if self.image_data is None:
            messagebox.showwarning("No Image", "Please load an image first")
            return
        
        try:
            # Reset cancellation flag
            self.processing_cancelled = False
            
            # Disable process button, enable cancel
            self.process_button.config(state="disabled")
            self.cancel_button.config(state="normal")
            
            # Get processing parameters
            method = self.depth_method.get()
            depth_scale = self.depth_scale.get()
            depth_contrast = self.depth_contrast.get()
            
            # Reset progress
            self.progress_var.set(0)
            self.root.update_idletasks()
            
            # Start timing
            start_time = time.time()
            
            # Process image
            depth_map = self.create_depth_from_image(self.image_data, method, depth_scale, depth_contrast)
            
            if self.processing_cancelled:
                self.process_status_label.config(text="Processing cancelled", foreground="orange")
                return
            
            # Calculate processing time
            processing_time = time.time() - start_time
            
            # Store current depth map
            self.current_depth_map = depth_map
            height, width = depth_map.shape
            x = np.linspace(0, width-1, width)
            y = np.linspace(0, height-1, height)
            self.current_coords = np.meshgrid(x, y)
            
            # Debug info
            debug_text = f"Method: {method}\nProcessing time: {processing_time:.2f}s\nDepth range: [{depth_map.min():.4f}, {depth_map.max():.4f}]\nNon-zero pixels: {np.count_nonzero(depth_map)}/{depth_map.size}"
            self.debug_label.config(text=debug_text)
            
            # Update status
            self.process_status_label.config(
                text=f"âœ… Processed using {method} method in {processing_time:.2f}s", 
                foreground="green"
            )
            
            # Enable visualization and export buttons
            self.update_viz_button.config(state="normal")
            self.export_button.config(state="normal")
            
            # Show the depth map
            self.visualize_depth_map()
            
            messagebox.showinfo("Success", f"Image processed to depth map using {method} method in {processing_time:.2f} seconds")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process image: {str(e)}")
        finally:
            # Re-enable process button, disable cancel
            self.process_button.config(state="normal")
            self.cancel_button.config(state="disabled")
            self.progress_var.set(0)
    
    def create_depth_from_image(self, image_data, method, depth_scale, depth_contrast):
        """Create depth map from image using specified method."""
        # Convert to float
        image_float = image_data.astype(np.float32) / 255.0
        
        if method == "luminosity":
            # Standard luminosity formula
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        
        elif method == "rgb_magnitude":
            # RGB vector magnitude
            depth = np.sqrt(image_float[:,:,0]**2 + image_float[:,:,1]**2 + image_float[:,:,2]**2) / np.sqrt(3)
        
        elif method == "saturation":
            # Color saturation
            max_color = np.max(image_float, axis=2)
            min_color = np.min(image_float, axis=2)
            depth = np.where(max_color > 0, (max_color - min_color) / max_color, 0)
        
        elif method == "edges":
            # Edge detection depth
            gray = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
            gray_uint8 = (gray * 255).astype(np.uint8)
            edges = cv2.Canny(gray_uint8, 50, 150)
            depth = edges.astype(np.float32) / 255.0
        
        elif method == "gs_coordinate":
            # FIXED: True G-S coordinate method
            if self.full_sampling.get():
                depth = self.create_gs_depth_full_sampling(image_float)
            else:
                depth = self.create_gs_depth_from_image_fixed(image_float)
        
        else:
            # Default to luminosity
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        
        # Apply scaling and contrast
        depth = depth * depth_scale
        depth = np.power(np.clip(depth, 0, 1), depth_contrast)
        
        return depth
    
    # FIXED: Replaced the old G-S method with true S-coordinate calculation
    def create_gs_depth_full_sampling(self, image_float):
        """FIXED G-S method using true S-coordinate calculation."""
        height, width, _ = image_float.shape
        
        # Get Hadit parameters
        hadit_theta = np.radians(self.hadit_theta.get())
        hadit_phi = np.radians(self.hadit_phi.get())
        nuit_radius = self.nuit_radius.get()
        
        # Create Hadit vector
        hadit_3d = np.array([
            np.sin(hadit_phi) * np.cos(hadit_theta),
            np.sin(hadit_phi) * np.sin(hadit_theta),
            np.cos(hadit_phi)
        ])
        
        depth_map = np.zeros((height, width))
        
        print(f"FIXED G-S method: Calculating true S-coordinates...")
        print(f"Hadit vector: {hadit_3d}")
        print(f"Nuit radius: {nuit_radius}")
        
        # Process each pixel to calculate S-coordinate
        for y in range(height):
            for x in range(width):
                rgb_vector = image_float[y, x]
                
                # Calculate S-coordinate (quantum intersection)
                s_coord = self.calculate_s_coordinate(rgb_vector, hadit_3d)
                
                # Calculate alignment depth
                depth_map[y, x] = self.calculate_alignment_depth(s_coord, nuit_radius)
            
            # Progress update
            if y % (height // 10) == 0:
                progress = (y / height) * 100
                self.progress_var.set(progress)
                self.root.update_idletasks()
                if self.processing_cancelled:
                    return np.zeros((height, width))
        
        print(f"FIXED G-S depth range: [{depth_map.min():.6f}, {depth_map.max():.6f}]")
        print(f"Non-zero pixels: {np.count_nonzero(depth_map)}/{height*width} ({100*np.count_nonzero(depth_map)/(height*width):.1f}%)")
        
        return depth_map

    # FIXED: New method to calculate true S-coordinate
    def calculate_s_coordinate(self, rgb_vector, hadit_vector):
        """Calculate S-coordinate from G-Hadit intersection (TRUE quantum geometry)."""
        # Convert RGB to G-vector magnitude and direction
        g_magnitude = np.linalg.norm(rgb_vector)
        if g_magnitude < 1e-8:
            return np.array([0.0, 0.0])
        
        g_unit = rgb_vector / g_magnitude
        
        # G spherical coordinates
        g_theta = np.arctan2(g_unit[1], g_unit[0])
        g_phi = np.arccos(np.clip(g_unit[2], -1, 1))
        
        # Hadit spherical coordinates
        hadit_magnitude = np.linalg.norm(hadit_vector)
        hadit_unit = hadit_vector / hadit_magnitude
        hadit_theta = np.arctan2(hadit_unit[1], hadit_unit[0])
        hadit_phi = np.arccos(np.clip(hadit_unit[2], -1, 1))
        
        # TRUE S-coordinate calculation (matches your alignment data structure)
        # This calculates the intersection point in the Nuit plane
        g_proj_x = g_magnitude * np.sin(g_phi) * np.cos(g_theta)
        g_proj_y = g_magnitude * np.sin(g_phi) * np.sin(g_theta)
        
        hadit_proj_x = hadit_magnitude * np.sin(hadit_phi) * np.cos(hadit_theta)
        hadit_proj_y = hadit_magnitude * np.sin(hadit_phi) * np.sin(hadit_theta)
        
        # S-coordinate is the quantum interference pattern
        s_x = g_proj_x - hadit_proj_x * np.cos(g_theta - hadit_theta)
        s_y = g_proj_y - hadit_proj_y * np.sin(g_theta - hadit_theta)
        
        return np.array([s_x, s_y])

    # FIXED: New method to calculate alignment depth from S-coordinate
    def calculate_alignment_depth(self, s_coordinate, nuit_radius=0.5):
        """Calculate depth based on quantum alignment quality."""
        # Distance from origin
        dist_origin = np.linalg.norm(s_coordinate)
        
        # Distance from Nuit boundary (the key quantum constraint)
        dist_boundary = abs(dist_origin - nuit_radius)
        
        # Quantum alignment scoring
        if dist_boundary < 0.001:
            return 1.0  # Perfect alignment (like your dist_boundary=0 cases)
        elif dist_origin <= nuit_radius:
            # Inside Nuit boundary - high alignment
            return 0.8 + 0.2 / (1.0 + dist_boundary * 10)
        else:
            # Outside Nuit boundary - decreasing alignment
            return 0.5 / (1.0 + dist_boundary)
    
    def create_gs_depth_from_image_fixed(self, image_float):
        """Create depth using sparse G-S alignment method for comparison."""
        height, width, _ = image_float.shape
        depth_map = np.zeros((height, width))
        
        # Get Hadit parameters
        hadit_theta = np.radians(self.hadit_theta.get())
        hadit_phi = np.radians(self.hadit_phi.get())
        nuit_radius = self.nuit_radius.get()
        
        # Create Hadit vector
        hadit_3d = np.array([
            np.sin(hadit_phi) * np.cos(hadit_theta),
            np.sin(hadit_phi) * np.sin(hadit_theta),
            np.cos(hadit_phi)
        ])
        
        print(f"Sparse sampling FIXED G-S method with Hadit vector: {hadit_3d}")
        
        # Process in batches for efficiency (sparse method)
        sample_rate = max(1, min(height//50, width//50))
        for y in range(0, height, sample_rate):
            for x in range(0, width, sample_rate):
                rgb_vector = image_float[y, x]
                
                # Calculate S-coordinate
                s_coord = self.calculate_s_coordinate(rgb_vector, hadit_3d)
                
                # Calculate alignment depth
                depth_value = self.calculate_alignment_depth(s_coord, nuit_radius)
                
                # Fill a small region around this pixel
                y_start = max(0, y)
                y_end = min(height, y + sample_rate)
                x_start = max(0, x)
                x_end = min(width, x + sample_rate)
                
                depth_map[y_start:y_end, x_start:x_end] = depth_value
        
        print(f"Sparse FIXED G-S depth range: [{depth_map.min():.6f}, {depth_map.max():.6f}]")
        
        return depth_map
    
    def test_gs_method(self):
        """Test G-S method with a synthetic pattern."""
        # Create a test pattern
        size = 256
        test_image = np.zeros((size, size, 3), dtype=np.float32)
        
        # Create a gradient pattern
        for y in range(size):
            for x in range(size):
                # Create radial gradient
                center_x, center_y = size // 2, size // 2
                distance = np.sqrt((x - center_x)**2 + (y - center_y)**2)
                normalized_distance = distance / (size // 2)
                
                # Color based on position
                test_image[y, x, 0] = np.sin(x / size * np.pi) * 0.5 + 0.5  # Red
                test_image[y, x, 1] = np.sin(y / size * np.pi) * 0.5 + 0.5  # Green
                test_image[y, x, 2] = (1 - normalized_distance) if normalized_distance < 1 else 0  # Blue
        
        # Store test image
        self.image_data = (test_image * 255).astype(np.uint8)
        self.loaded_image = Image.fromarray(self.image_data)
        
        # Update status
        self.image_status_label.config(
            text=f"âœ… Test pattern created ({size}x{size})",
            foreground="green"
        )
        
        # Enable process button
        self.process_button.config(state="normal")
        self.process_status_label.config(text="Test pattern ready for FIXED G-S processing", foreground="blue")
        
        # Show the test image
        self.show_loaded_image()
        
        # Auto-select G-S method and full sampling
        self.depth_method.set("gs_coordinate")
        self.full_sampling.set(True)
        
        messagebox.showinfo("Test Pattern", "Created synthetic test pattern for FIXED G-S method testing.\nNow try both RGB Magnitude and G-S Coordinate methods to see the difference!")
    
    def visualize_depth_map(self):
        """Visualize the current depth map."""
        if self.current_depth_map is None:
            return
        
        self.fig.clear()
        
        # Create subplots
        if self.image_data is not None:
            ax1 = self.fig.add_subplot(131)
            ax2 = self.fig.add_subplot(132)
            ax3 = self.fig.add_subplot(133)
            
            # Show original image
            ax1.imshow(self.image_data)
            ax1.set_title("Original Image")
            ax1.axis('off')
            
            # Show depth map
            im = ax2.imshow(self.current_depth_map, cmap=self.colormap.get())
            sampling_mode = "Full Pixel" if self.full_sampling.get() else "Sparse"
            method_name = "FIXED G-S" if self.depth_method.get() == "gs_coordinate" else self.depth_method.get()
            ax2.set_title(f"Depth Map ({method_name} - {sampling_mode})")
            ax2.axis('off')
            
            # Show depth statistics
            ax3.hist(self.current_depth_map.flatten(), bins=50, alpha=0.7, color='blue')
            ax3.set_xlabel("Depth Value")
            ax3.set_ylabel("Pixel Count")
            ax3.set_title(f"Depth Distribution\nRange: [{self.current_depth_map.min():.3f}, {self.current_depth_map.max():.3f}]")
            
            # Add colorbar
            self.fig.colorbar(im, ax=ax2, label='Depth')
            
        else:
            ax2 = self.fig.add_subplot(111)
            
            # Show depth map only
            im = ax2.imshow(self.current_depth_map, cmap=self.colormap.get())
            sampling_mode = "Full Pixel" if self.full_sampling.get() else "Sparse"
            method_name = "FIXED G-S" if self.depth_method.get() == "gs_coordinate" else self.depth_method.get()
            ax2.set_title(f"Depth Map ({method_name} - {sampling_mode})\nRange: [{self.current_depth_map.min():.3f}, {self.current_depth_map.max():.3f}]")
            ax2.axis('off')
            
            # Add colorbar
            self.fig.colorbar(im, ax=ax2, label='Depth')
        
        self.fig.tight_layout()
        self.canvas.draw()
    
    def update_visualization(self):
        """Update the visualization with current parameters."""
        if self.current_depth_map is not None:
            if hasattr(self, 'alignment_data') and self.alignment_data:
                # If we have alignment data, use the specialized visualization
                self.visualize_gs_alignment_depth_map(self.alignment_data)
            else:
                # Regular depth map visualization
                self.visualize_depth_map()
    
    def export_depth_map(self):
        """Export the current depth map."""
        if self.current_depth_map is None:
            messagebox.showwarning("No Depth Map", "Please process data first")
            return
        
        # Ask for output file
        filename = filedialog.asksaveasfilename(
            title="Save Depth Map",
            defaultextension=".png",
            filetypes=[
                ("PNG files", "*.png"),
                ("TIFF files", "*.tiff"),
                ("NumPy files", "*.npy"),
                ("All files", "*.*")
            ]
        )
        
        if filename:
            try:
                if filename.endswith('.npy'):
                    # Save as numpy array
                    np.save(filename, self.current_depth_map)
                else:
                    # Save as image
                    if filename.endswith('.tiff'):
                        # 16-bit TIFF
                        depth_16bit = (self.current_depth_map * 65535).astype(np.uint16)
                        cv2.imwrite(filename, depth_16bit)
                    else:
                        # 8-bit PNG
                        depth_8bit = (self.current_depth_map * 255).astype(np.uint8)
                        cv2.imwrite(filename, depth_8bit)
                
                messagebox.showinfo("Success", f"Depth map exported to {filename}")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {str(e)}")
    
    def load_sample_data(self):
        """Load sample alignment data for testing without an image."""
        # Generate sample data
        np.random.seed(42)
        resolution = self.resolution.get()
        
        # Create a synthetic depth map with interesting features
        x = np.linspace(-2, 2, resolution)
        y = np.linspace(-2, 2, resolution)
        X, Y = np.meshgrid(x, y)
        
        # Create depth pattern based on your alignment structure
        depth_map = np.zeros_like(X)
        
        # Add perfect alignment peaks at specific locations (your quantum levels)
        peak_locations = [(-0.5, 0), (0.5, 0), (0, -0.5), (0, 0.5), (0, 0)]
        
        for px, py in peak_locations:
            # Create Gaussian peaks
            sigma = 0.3
            peak = np.exp(-((X - px)**2 + (Y - py)**2) / (2 * sigma**2))
            depth_map += peak
        
        # Add some noise and structure
        depth_map += 0.1 * np.sin(2*np.pi*X) * np.cos(2*np.pi*Y)
        
        # Add circular Nuit boundary effect
        nuit_radius = self.nuit_radius.get()
        distance_from_origin = np.sqrt(X**2 + Y**2)
        boundary_effect = np.exp(-((distance_from_origin - nuit_radius)**2) / (2 * 0.1**2))
        depth_map += 0.5 * boundary_effect
        
        # Normalize
        depth_map = (depth_map - depth_map.min()) / (depth_map.max() - depth_map.min())
        
        # Store the depth map
        self.current_depth_map = depth_map
        self.current_coords = (X, Y)
        
        # Enable buttons
        self.update_viz_button.config(state="normal")
        self.export_button.config(state="normal")
        
        # Update status
        self.process_status_label.config(text="âœ… Sample G-S alignment depth map created", foreground="green")
        
        # Debug info
        debug_text = f"Sample Data\nDepth range: [{depth_map.min():.4f}, {depth_map.max():.4f}]\nPeaks: {len(peak_locations)}"
        self.debug_label.config(text=debug_text)
        
        # Show the depth map
        self.fig.clear()
        ax = self.fig.add_subplot(111)
        im = ax.imshow(depth_map, cmap=self.colormap.get(), extent=[-2, 2, -2, 2])
        ax.set_title("Sample G-S Alignment Depth Map\n(Perfect Alignment Peaks + Nuit Boundary)")
        ax.set_xlabel("S_x")
        ax.set_ylabel("S_y")
        
        # Mark perfect alignment locations
        for px, py in peak_locations:
            ax.plot(px, py, 'r*', markersize=10, label='Perfect Alignment' if px == peak_locations[0][0] else "")
        
        # Draw Nuit boundary
        circle = plt.Circle((0, 0), nuit_radius, fill=False, color='red', linewidth=2, linestyle='--')
        ax.add_patch(circle)
        
        ax.legend()
        self.fig.colorbar(im, ax=ax, label='Depth')
        self.canvas.draw()
        
        messagebox.showinfo("Sample Data", f"Generated G-S alignment depth map with {len(peak_locations)} perfect alignment peaks")

def main():
    """Main function to run the GUI application."""
    root = tk.Tk()
    app = GSDepthMapperGUI(root)
    
    # Add some styling
    style = ttk.Style()
    style.theme_use('clam')
    
    root.mainloop()

if __name__ == "__main__":
    main()
