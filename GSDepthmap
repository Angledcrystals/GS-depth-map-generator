import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import cv2
import os
from PIL import Image, ImageTk
import time
from scipy.ndimage import gaussian_filter
from scipy.spatial.distance import cdist
from scipy.interpolate import griddata

class GSDepthMapperGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("G-S Alignment Depth Mapper - Enhanced Quantum Method v6")
        self.root.geometry("1400x900")
        
        # Data storage
        self.alignment_data = []
        self.alignments_by_condition = {}
        self.alignments_by_radius = {}
        self.perfect_alignments = []
        self.current_depth_map = None
        self.current_coords = None
        self.loaded_image = None
        self.image_data = None
        
        # Default parameters
        self.resolution = tk.IntVar(value=256)
        self.colormap = tk.StringVar(value="viridis")
        self.nuit_radius = tk.DoubleVar(value=0.5) 
        
        # Image processing parameters
        self.hadit_theta = tk.DoubleVar(value=45.0)
        self.hadit_phi = tk.DoubleVar(value=60.0)
        self.depth_method = tk.StringVar(value="luminosity")
        self.depth_scale = tk.DoubleVar(value=1.0)
        self.depth_contrast = tk.DoubleVar(value=1.0)
        self.gs_scale = tk.DoubleVar(value=1.0)
        
        # Enhanced alignment processing parameters
        self.quality_weighting = tk.BooleanVar(value=True)
        self.multi_condition_fusion = tk.BooleanVar(value=False)
        self.adaptive_sampling = tk.BooleanVar(value=True)
        self.auto_optimize_params = tk.BooleanVar(value=False)
        
        # Full sampling control
        self.full_sampling = tk.BooleanVar(value=True)
        self.processing_cancelled = False
        
        self.setup_gui()
        
    def setup_gui(self):
        """Setup the main GUI layout."""
        control_container = ttk.Frame(self.root)
        control_container.pack(side=tk.LEFT, fill=tk.Y, padx=10, pady=10)
        
        viz_frame = ttk.Frame(self.root)
        viz_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.setup_scrollable_control_panel(control_container)
        self.setup_visualization_panel(viz_frame)
        
    def setup_scrollable_control_panel(self, parent):
        """Setup a scrollable control panel."""
        canvas = tk.Canvas(parent, width=350, highlightthickness=0)
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)
        
        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )
        
        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)
        
        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        def _on_mousewheel(event):
            canvas.yview_scroll(int(-1*(event.delta/120)), "units")
        
        def _bind_to_mousewheel(event):
            canvas.bind_all("<MouseWheel>", _on_mousewheel)
        
        def _unbind_from_mousewheel(event):
            canvas.unbind_all("<MouseWheel>")
        
        canvas.bind('<Enter>', _bind_to_mousewheel)
        canvas.bind('<Leave>', _unbind_from_mousewheel)
        
        self.setup_control_panel(scrollable_frame)
        
    def setup_control_panel(self, parent):
        """Setup the control panel content."""
        title_label = ttk.Label(parent, text="G-S Depth Mapper Enhanced", font=("Arial", 16, "bold"))
        title_label.pack(pady=(0, 20))
        
        image_frame = ttk.LabelFrame(parent, text="Step 1: Load Data", padding=10)
        image_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Button(image_frame, text="ðŸ“ Load Image File", 
                  command=self.load_image, width=25).pack(fill=tk.X, pady=2)
        
        ttk.Button(image_frame, text="ðŸ“Š Load G-S Alignment Data", 
                  command=self.load_alignment_data, width=25).pack(fill=tk.X, pady=2)
        
        self.image_status_label = ttk.Label(image_frame, text="No data loaded", foreground="red")
        self.image_status_label.pack(pady=5)
        
        params_frame = ttk.LabelFrame(parent, text="Step 2: Processing Parameters", padding=10)
        params_frame.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(params_frame, text="Depth Method:").pack(anchor=tk.W)
        methods = [
            ("Luminosity (Brightness)", "luminosity"),
            ("RGB Magnitude", "rgb_magnitude"),
            ("Saturation", "saturation"),
            ("G-S Coordinate (Enhanced Geometric)", "gs_coordinate_enhanced"),
            ("Edge Detection", "edges")
        ]
        
        for text, value in methods:
            ttk.Radiobutton(params_frame, text=text, variable=self.depth_method, 
                           value=value).pack(anchor=tk.W)
        
        ttk.Label(params_frame, text="Depth Scale:").pack(anchor=tk.W, pady=(10, 0))
        scale_frame = ttk.Frame(params_frame)
        scale_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(scale_frame, from_=0.1, to=5.0, variable=self.depth_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(scale_frame, textvariable=self.depth_scale, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(params_frame, text="Depth Contrast:").pack(anchor=tk.W, pady=(10, 0))
        contrast_frame = ttk.Frame(params_frame)
        contrast_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(contrast_frame, from_=0.1, to=3.0, variable=self.depth_contrast, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(contrast_frame, textvariable=self.depth_contrast, width=8).pack(side=tk.RIGHT)
        
        # Enhanced G-S Parameters
        gs_frame = ttk.LabelFrame(params_frame, text="Enhanced G-S Parameters", padding=5)
        gs_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Checkbutton(gs_frame, text="Quality-weighted interpolation", 
                       variable=self.quality_weighting).pack(anchor=tk.W, pady=2)
        
        ttk.Checkbutton(gs_frame, text="Multi-condition fusion (3D reconstruction)", 
                       variable=self.multi_condition_fusion).pack(anchor=tk.W, pady=2)
        
        ttk.Checkbutton(gs_frame, text="Adaptive sampling based on alignment density", 
                       variable=self.adaptive_sampling).pack(anchor=tk.W, pady=2)
        
        ttk.Checkbutton(gs_frame, text="Auto-optimize parameters from perfect alignments", 
                       variable=self.auto_optimize_params).pack(anchor=tk.W, pady=2)
        
        ttk.Checkbutton(gs_frame, text="Full pixel sampling (higher quality, slower)", 
                       variable=self.full_sampling).pack(anchor=tk.W, pady=(5, 5))
        
        ttk.Label(gs_frame, text="Hadit Î¸ (degrees):").pack(anchor=tk.W)
        theta_frame = ttk.Frame(gs_frame)
        theta_frame.pack(fill=tk.X)
        ttk.Scale(theta_frame, from_=0, to=360, variable=self.hadit_theta, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(theta_frame, textvariable=self.hadit_theta, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="Hadit Ï† (degrees):").pack(anchor=tk.W)
        phi_frame = ttk.Frame(gs_frame)
        phi_frame.pack(fill=tk.X)
        ttk.Scale(phi_frame, from_=0, to=180, variable=self.hadit_phi, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(phi_frame, textvariable=self.hadit_phi, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="Nuit Radius (Contextual):").pack(anchor=tk.W)
        nuit_frame = ttk.Frame(gs_frame)
        nuit_frame.pack(fill=tk.X)
        ttk.Scale(nuit_frame, from_=0.1, to=2.0, variable=self.nuit_radius, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(nuit_frame, textvariable=self.nuit_radius, width=8).pack(side=tk.RIGHT)
        
        ttk.Label(gs_frame, text="G-S Scale Factor (Sphere Radius):").pack(anchor=tk.W)
        gs_scale_frame = ttk.Frame(gs_frame)
        gs_scale_frame.pack(fill=tk.X)
        ttk.Scale(gs_scale_frame, from_=0.1, to=10.0, variable=self.gs_scale, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(gs_scale_frame, textvariable=self.gs_scale, width=8).pack(side=tk.RIGHT)
        
        process_frame = ttk.LabelFrame(parent, text="Step 3: Process Image", padding=10)
        process_frame.pack(fill=tk.X, pady=(0, 10))
        
        button_frame = ttk.Frame(process_frame)
        button_frame.pack(fill=tk.X, pady=2)
        
        self.process_button = ttk.Button(button_frame, text="ðŸ”„ Process Image to Depth Map", 
                                        command=self.process_image_to_depth_map, 
                                        width=20, state="disabled")
        self.process_button.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 5))
        
        self.cancel_button = ttk.Button(button_frame, text="âŒ Cancel", 
                                       command=self.cancel_processing, 
                                       width=8, state="disabled")
        self.cancel_button.pack(side=tk.RIGHT)
        
        self.process_status_label = ttk.Label(process_frame, text="Load data first", foreground="orange")
        self.process_status_label.pack(pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(process_frame, variable=self.progress_var, 
                                          maximum=100, length=300)
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        viz_frame_control = ttk.LabelFrame(parent, text="Step 4: Visualization", padding=10)
        viz_frame_control.pack(fill=tk.X, pady=(0, 10))
        
        ttk.Label(viz_frame_control, text="Resolution:").pack(anchor=tk.W)
        resolution_frame = ttk.Frame(viz_frame_control)
        resolution_frame.pack(fill=tk.X, pady=2)
        ttk.Scale(resolution_frame, from_=64, to=1024, variable=self.resolution, 
                 orient=tk.HORIZONTAL).pack(side=tk.LEFT, fill=tk.X, expand=True)
        ttk.Label(resolution_frame, textvariable=self.resolution, width=5).pack(side=tk.RIGHT)
        
        ttk.Label(viz_frame_control, text="Colormap:").pack(anchor=tk.W, pady=(10, 0))
        colormap_combo = ttk.Combobox(viz_frame_control, textvariable=self.colormap, 
                                     values=["viridis", "plasma", "hot", "coolwarm", 
                                            "jet", "terrain", "ocean", "rainbow", "gray"])
        colormap_combo.pack(fill=tk.X, pady=2)
        
        self.update_viz_button = ttk.Button(viz_frame_control, text="ðŸŽ¨ Update Visualization", 
                                           command=self.update_visualization, 
                                           state="disabled")
        self.update_viz_button.pack(fill=tk.X, pady=5)
        
        self.select_condition_button = ttk.Button(viz_frame_control, text="ðŸŽ›ï¸ Select Conditions", 
                                                 command=self.select_alignment_condition, 
                                                 state="disabled")
        self.select_condition_button.pack(fill=tk.X, pady=2)
        
        debug_frame = ttk.LabelFrame(viz_frame_control, text="Debug Info", padding=5)
        debug_frame.pack(fill=tk.X, pady=(10, 0))
        
        self.debug_label = ttk.Label(debug_frame, text="No processing done yet", font=("Courier", 8))
        self.debug_label.pack(fill=tk.X)
        
        export_frame = ttk.LabelFrame(parent, text="Step 5: Export", padding=10)
        export_frame.pack(fill=tk.X, pady=(0, 10))
        
        self.export_button = ttk.Button(export_frame, text="ðŸ’¾ Export Depth Map", 
                                       command=self.export_depth_map, 
                                       state="disabled")
        self.export_button.pack(fill=tk.X, pady=2)
        
        quick_frame = ttk.LabelFrame(parent, text="Quick Test", padding=10)
        quick_frame.pack(fill=tk.X, pady=(10, 0))
        
        ttk.Button(quick_frame, text="ðŸ§ª Load Sample Data", 
                  command=self.load_sample_data).pack(fill=tk.X, pady=2)
        
        ttk.Button(quick_frame, text="ðŸŽ¯ Test Enhanced G-S Method", 
                  command=self.test_gs_method).pack(fill=tk.X, pady=2)
        
        ttk.Label(parent, text=" ").pack(pady=20)
        
    def setup_visualization_panel(self, parent):
        self.fig = Figure(figsize=(12, 10), dpi=100)
        self.canvas = FigureCanvasTkAgg(self.fig, parent)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        toolbar_frame = ttk.Frame(parent)
        toolbar_frame.pack(fill=tk.X)
        
        from matplotlib.backends.backend_tkagg import NavigationToolbar2Tk
        toolbar = NavigationToolbar2Tk(self.canvas, toolbar_frame)
        toolbar.update()
        
        self.show_empty_plot()
    
    def show_empty_plot(self):
        self.fig.clear()
        ax = self.fig.add_subplot(111)
        ax.text(0.5, 0.5, "Load data to get started!\n\n1. Click 'Load Image File' or 'Load G-S Alignment Data'\n2. Adjust enhanced parameters\n3. Click 'Process Image to Depth Map'", 
                ha='center', va='center', fontsize=14, transform=ax.transAxes)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.set_title("G-S Depth Mapper - Enhanced Quantum Method (v6)")
        self.canvas.draw()
    
    def load_image(self):
        filename = filedialog.askopenfilename(
            title="Select Image File",
            filetypes=[("Image files", "*.png *.jpg *.jpeg *.tiff *.tif *.bmp *.gif"), ("All files", "*.*")]
        )
        if filename:
            try:
                pil_image = Image.open(filename)
                if pil_image.mode != 'RGB':
                    pil_image = pil_image.convert('RGB')
                self.loaded_image = pil_image
                self.image_data = np.array(pil_image)
                self.image_status_label.config(
                    text=f"âœ… Loaded: {os.path.basename(filename)} ({self.image_data.shape[1]}x{self.image_data.shape[0]})",
                    foreground="green"
                )
                self.process_button.config(state="normal")
                self.process_status_label.config(text="Ready to process image", foreground="blue")
                self.show_loaded_image()
                messagebox.showinfo("Success", f"Image loaded: {os.path.basename(filename)}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load image: {str(e)}")
    
    def load_alignment_data(self):
        filename = filedialog.askopenfilename(
            title="Select G-S Alignment Data File",
            filetypes=[("Text files", "*.txt"), ("CSV files", "*.csv"), ("All files", "*.*")]
        )
        if filename:
            try:
                self.parse_gs_alignment_file(filename)
                messagebox.showinfo("Success", f"G-S alignment data loaded from {os.path.basename(filename)}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load alignment data: {str(e)}")

    def parse_gs_alignment_file(self, filename):
        with open(filename, 'r') as f:
            content = f.read()
        lines = content.split('\n')
        total_alignments_from_summary = 0
        for line in lines:
            if "Total alignments found:" in line:
                total_alignments_from_summary = int(line.split(":")[1].strip())
                break
        
        all_alignments = []
        current_condition = None
        parsing_data = False
        
        for line in lines:
            line = line.strip()
            if "CONDITION:" in line and "PROJECTION" in line:
                current_condition = line.replace("CONDITION: ", "").strip()
                parsing_data = False
                continue
            if line.startswith("G_theta_deg,G_phi_deg,Hadit_theta_deg"):
                parsing_data = True
                continue
            if parsing_data and line and not line.startswith("=") and "," in line:
                try:
                    parts = line.split(',')
                    if len(parts) >= 11:
                        alignment = {
                            'condition': current_condition,
                            'G_theta': float(parts[0]), 'G_phi': float(parts[1]),
                            'Hadit_theta': float(parts[2]), 'Hadit_phi': float(parts[3]),
                            'S_x': float(parts[4]), 'S_y': float(parts[5]),
                            'dist_boundary': float(parts[6]), 'dist_origin': float(parts[7]),
                            'G_refl_x': float(parts[8]), 'G_refl_y': float(parts[9]),
                            'G_refl_z': float(parts[10])
                        }
                        all_alignments.append(alignment)
                except (ValueError, IndexError):
                    continue
            if parsing_data and line.startswith("="):
                parsing_data = False
        
        self.alignment_data = all_alignments
        self.organize_alignments_by_condition_and_radius()
        
        # Auto-optimize parameters if enabled
        if self.auto_optimize_params.get():
            self.optimize_parameters_from_alignments()
        
        self.create_enhanced_depth_map_from_alignments(all_alignments)
        self.image_status_label.config(
            text=f"âœ… G-S data: {len(all_alignments)} alignments", foreground="green"
        )
        self.select_condition_button.config(state="normal")
        print(f"Loaded {len(all_alignments)} G-S alignments from {total_alignments_from_summary} total (summary)")

    def organize_alignments_by_condition_and_radius(self):
        """Organize alignments by condition and radius for enhanced processing."""
        self.alignments_by_condition = {}
        self.alignments_by_radius = {}
        self.perfect_alignments = []
        
        for alignment in self.alignment_data:
            condition = alignment.get('condition', 'Unknown')
            
            # Group by condition
            if condition not in self.alignments_by_condition:
                self.alignments_by_condition[condition] = []
            self.alignments_by_condition[condition].append(alignment)
            
            # Group by radius (extract from condition string)
            radius = self.extract_radius_from_condition(condition)
            if radius is not None:
                if radius not in self.alignments_by_radius:
                    self.alignments_by_radius[radius] = []
                self.alignments_by_radius[radius].append(alignment)
            
            # Collect perfect alignments
            if alignment['dist_boundary'] < 0.001:
                self.perfect_alignments.append(alignment)
    
    def extract_radius_from_condition(self, condition_str):
        """Extract radius value from condition string."""
        try:
            if "RADIUS =" in condition_str:
                radius_part = condition_str.split("RADIUS =")[1].strip()
                radius_val = float(radius_part.split()[0])
                return radius_val
        except:
            pass
        return None
    
    def optimize_parameters_from_alignments(self):
        """Auto-optimize Hadit parameters based on perfect alignments."""
        if not self.perfect_alignments:
            print("No perfect alignments found for parameter optimization")
            return
        
        # Calculate optimal Hadit parameters from perfect alignments
        hadit_thetas = [a['Hadit_theta'] for a in self.perfect_alignments]
        hadit_phis = [a['Hadit_phi'] for a in self.perfect_alignments]
        
        optimal_theta = np.mean(hadit_thetas)
        optimal_phi = np.mean(hadit_phis)
        
        # Update GUI parameters
        self.hadit_theta.set(optimal_theta)
        self.hadit_phi.set(optimal_phi)
        
        print(f"Auto-optimized parameters: Î¸={optimal_theta:.1f}Â°, Ï†={optimal_phi:.1f}Â°")
        print(f"Based on {len(self.perfect_alignments)} perfect alignments")

    def create_enhanced_depth_map_from_alignments(self, alignments, grid_size=None):
        """Enhanced depth map creation with quality weighting and multi-condition fusion."""
        if not alignments:
            self.current_depth_map = None
            self.current_coords = None
            self.show_empty_plot()
            return

        if grid_size is None:
            grid_size = self.resolution.get()

        # Multi-condition fusion
        if self.multi_condition_fusion.get() and len(self.alignments_by_condition) > 1:
            depth_map = self.fuse_multi_condition_depth(grid_size)
        else:
            depth_map = self.create_quality_weighted_depth_map(alignments, grid_size)
        
        if depth_map is None:
            return
            
        self.current_depth_map = depth_map
        
        # Calculate coordinate system
        s_x_coords = [a['S_x'] for a in alignments]
        s_y_coords = [a['S_y'] for a in alignments]
        x_min, x_max = min(s_x_coords), max(s_x_coords)
        y_min, y_max = min(s_y_coords), max(s_y_coords)
        
        height, width = depth_map.shape
        x_coords_grid = np.linspace(x_min, x_max, width)
        y_coords_grid = np.linspace(y_min, y_max, height)
        self.current_coords = np.meshgrid(x_coords_grid, y_coords_grid)
        
        self.update_viz_button.config(state="normal")
        self.export_button.config(state="normal")
        self.process_status_label.config(text="âœ… Enhanced G-S depth map created", foreground="green")
        
        # Update debug info
        unique_points = np.count_nonzero(depth_map)
        debug_text = (f"Enhanced G-S Depth Map\nTotal alignments: {len(alignments)}\n"
                      f"Perfect alignments: {len(self.perfect_alignments)}\n"
                      f"Conditions: {len(self.alignments_by_condition)}\n"
                      f"Quality weighting: {'ON' if self.quality_weighting.get() else 'OFF'}\n"
                      f"Multi-condition: {'ON' if self.multi_condition_fusion.get() else 'OFF'}\n"
                      f"Depth range: [{depth_map.min():.4f}, {depth_map.max():.4f}]")
        self.debug_label.config(text=debug_text)
        
        self.visualize_enhanced_alignment_depth_map(alignments)

    def create_quality_weighted_depth_map(self, alignments, grid_size):
        """Create depth map with quality-weighted interpolation."""
        processed_depth_values = []
        valid_s_x = []
        valid_s_y = []
        weights = []

        for a in alignments:
            condition_str = a.get('condition', '').upper()
            depth_val = 0
            
            # Extract depth based on projection type
            if "XY PROJECTION" in condition_str:
                depth_val = a['G_refl_z']
            elif "XZ PROJECTION" in condition_str:
                depth_val = a['G_refl_y']
            elif "YZ PROJECTION" in condition_str:
                depth_val = a['G_refl_x']
            else:
                continue
            
            processed_depth_values.append(depth_val)
            valid_s_x.append(a['S_x'])
            valid_s_y.append(a['S_y'])
            
            # Quality weighting
            if self.quality_weighting.get():
                # Higher weight for perfect alignments
                weight = 1.0 / (a['dist_boundary'] + 1e-6)
                # Boost perfect alignments even more
                if a['dist_boundary'] < 0.001:
                    weight *= 10.0
            else:
                weight = 1.0
            weights.append(weight)

        if not valid_s_x:
            return np.zeros((grid_size, grid_size))

        # Create coordinate grids
        x_min, x_max = min(valid_s_x), max(valid_s_x)
        y_min, y_max = min(valid_s_y), max(valid_s_y)
        
        # Use adaptive sampling if enabled
        if self.adaptive_sampling.get():
            grid_size = self.calculate_adaptive_grid_size(valid_s_x, valid_s_y, weights)
        
        depth_map = np.zeros((grid_size, grid_size))
        weight_map = np.zeros((grid_size, grid_size))
        
        # Quality-weighted binning
        for sx, sy, depth, weight in zip(valid_s_x, valid_s_y, processed_depth_values, weights):
            if x_max > x_min:
                grid_x = int((sx - x_min) / (x_max - x_min) * (grid_size - 1))
            else:
                grid_x = grid_size // 2
            if y_max > y_min:
                grid_y = int((sy - y_min) / (y_max - y_min) * (grid_size - 1))
            else:
                grid_y = grid_size // 2
            
            grid_x = max(0, min(grid_size - 1, grid_x))
            grid_y = max(0, min(grid_size - 1, grid_y))
            
            depth_map[grid_y, grid_x] += depth * weight
            weight_map[grid_y, grid_x] += weight
        
        # Weighted averaging
        valid_mask = weight_map > 0
        depth_map[valid_mask] /= weight_map[valid_mask]
        
        # Enhanced smoothing with quality consideration
        if np.any(valid_mask):
            # Smooth with sigma proportional to local quality
            sigma = 2.0 if self.quality_weighting.get() else 1.0
            smoothed_depth = gaussian_filter(depth_map, sigma=sigma)
            
            # Quality-based blending
            quality_mask = weight_map > np.mean(weight_map[valid_mask])
            final_depth = np.where(quality_mask, depth_map, smoothed_depth)
        else:
            final_depth = depth_map

        return final_depth

    def fuse_multi_condition_depth(self, grid_size):
        """Fuse depth information from multiple projection conditions."""
        if len(self.alignments_by_condition) < 2:
            return self.create_quality_weighted_depth_map(self.alignment_data, grid_size)
        
        condition_depth_maps = {}
        condition_weights = {}
        
        # Create depth maps for each condition
        for condition, alignments in self.alignments_by_condition.items():
            if len(alignments) < 10:  # Skip conditions with too few alignments
                continue
                
            depth_map = self.create_quality_weighted_depth_map(alignments, grid_size)
            if depth_map is not None:
                condition_depth_maps[condition] = depth_map
                
                # Weight conditions by number of perfect alignments
                perfect_count = sum(1 for a in alignments if a['dist_boundary'] < 0.001)
                condition_weights[condition] = perfect_count + 1
        
        if not condition_depth_maps:
            return self.create_quality_weighted_depth_map(self.alignment_data, grid_size)
        
        # Fuse depth maps with weighted averaging
        fused_depth = np.zeros((grid_size, grid_size))
        total_weight = np.zeros((grid_size, grid_size))
        
        for condition, depth_map in condition_depth_maps.items():
            weight = condition_weights[condition]
            fused_depth += depth_map * weight
            total_weight += weight
        
        # Normalize
        valid_mask = total_weight > 0
        fused_depth[valid_mask] /= total_weight[valid_mask]
        
        print(f"Fused {len(condition_depth_maps)} conditions for enhanced 3D depth")
        return fused_depth

    def calculate_adaptive_grid_size(self, s_x_coords, s_y_coords, weights):
        """Calculate optimal grid size based on alignment density."""
        base_grid_size = self.resolution.get()
        
        # Calculate density-weighted coverage
        weight_sum = sum(weights)
        coverage_area = (max(s_x_coords) - min(s_x_coords)) * (max(s_y_coords) - min(s_y_coords))
        
        if coverage_area > 0:
            density = weight_sum / coverage_area
            # Adjust grid size based on density
            adaptive_factor = min(2.0, max(0.5, density / 100.0))
            adaptive_grid_size = int(base_grid_size * adaptive_factor)
            return max(64, min(1024, adaptive_grid_size))
        
        return base_grid_size

    def visualize_enhanced_alignment_depth_map(self, alignments_for_scatter):
        """Enhanced visualization with quality overlays."""
        if self.current_depth_map is None or self.current_coords is None:
            return
        
        self.fig.clear()
        gs_gridspec = self.fig.add_gridspec(2, 3, hspace=0.4, wspace=0.3)
        
        # Main depth map
        ax1 = self.fig.add_subplot(gs_gridspec[0, :2])
        im1 = ax1.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto', origin='lower',
                         extent=[self.current_coords[0].min(), self.current_coords[0].max(),
                                 self.current_coords[1].min(), self.current_coords[1].max()])
        ax1.set_title(f"Enhanced G-S Depth Map ({self.current_depth_map.shape[1]}x{self.current_depth_map.shape[0]})")
        ax1.set_xlabel("S_x (Projection Plane)")
        ax1.set_ylabel("S_y (Projection Plane)")
        
        # Overlay perfect alignments
        if self.perfect_alignments:
            perfect_x = [a['S_x'] for a in self.perfect_alignments]
            perfect_y = [a['S_y'] for a in self.perfect_alignments]
            ax1.scatter(perfect_x, perfect_y, c='red', s=30, marker='*', 
                       label=f'Perfect Alignments ({len(self.perfect_alignments)})', alpha=0.8)
        
        # Overlay Nuit radius
        nuit_r_display = self.nuit_radius.get()
        circle = plt.Circle((0, 0), nuit_r_display, fill=False, color='cyan', linewidth=2, 
                           linestyle='--', alpha=0.8, label=f'Nuit Radius: {nuit_r_display}')
        ax1.add_patch(circle)
        
        ax1.legend(fontsize='small')
        self.fig.colorbar(im1, ax=ax1, label='Enhanced Depth Value')
        
        # Quality distribution
        ax2 = self.fig.add_subplot(gs_gridspec[0, 2])
        quality_scores = [1.0 / (a['dist_boundary'] + 1e-6) for a in alignments_for_scatter]
        ax2.hist(quality_scores, bins=30, alpha=0.7, color='orange')
        ax2.set_xlabel("Quality Score", fontsize=9)
        ax2.set_ylabel("Count", fontsize=9)
        ax2.set_title("Alignment Quality", fontsize=10)
        ax2.set_yscale('log')
        
        # Condition breakdown
        ax3 = self.fig.add_subplot(gs_gridspec[1, 0])
        if self.alignments_by_condition:
            condition_names = list(self.alignments_by_condition.keys())
            condition_counts = [len(aligns) for aligns in self.alignments_by_condition.values()]
            ax3.pie(condition_counts, labels=[name.split(',')[0].replace("PROJECTION", "P") 
                                            for name in condition_names], 
                    autopct='%1.1f%%', textprops={'fontsize': 8})
            ax3.set_title("By Condition", fontsize=10)
        
        # Radius breakdown
        ax4 = self.fig.add_subplot(gs_gridspec[1, 1])
        if self.alignments_by_radius:
            radius_names = [f"R={r}" for r in self.alignments_by_radius.keys()]
            radius_counts = [len(aligns) for aligns in self.alignments_by_radius.values()]
            ax4.pie(radius_counts, labels=radius_names, autopct='%1.1f%%', 
                    textprops={'fontsize': 8})
            ax4.set_title("By Radius", fontsize=10)
        
        # Depth distribution
        ax5 = self.fig.add_subplot(gs_gridspec[1, 2])
        if self.current_depth_map.size > 0:
            non_zero_depths = self.current_depth_map[self.current_depth_map != 0].flatten()
            if len(non_zero_depths) > 0:
                ax5.hist(non_zero_depths, bins=30, alpha=0.7, color='blue')
        ax5.set_xlabel("Depth Value", fontsize=9)
        ax5.set_ylabel("Pixel Count", fontsize=9)
        ax5.set_title("Enhanced Depth Distribution", fontsize=10)

        self.canvas.draw()

    def select_alignment_condition(self):
        if not hasattr(self, 'alignment_data') or not self.alignment_data:
            messagebox.showwarning("No Data", "Please load alignment data first")
            return
        
        unique_conditions = sorted(list(set(a['condition'] for a in self.alignment_data if a['condition'])))
        
        if not unique_conditions:
            messagebox.showwarning("No Conditions", "No condition data found in alignment file")
            return
        
        selection_window = tk.Toplevel(self.root)
        selection_window.title("Select Alignment Conditions")
        selection_window.geometry("450x400")
        
        ttk.Label(selection_window, text="Select conditions to include for Enhanced Depth Map:").pack(pady=10)
        
        listbox_frame = ttk.Frame(selection_window)
        listbox_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)

        listbox = tk.Listbox(listbox_frame, selectmode=tk.MULTIPLE, exportselection=False)
        for condition in unique_conditions:
            listbox.insert(tk.END, condition)
            listbox.select_set(tk.END)
        listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)

        scrollbar = ttk.Scrollbar(listbox_frame, orient=tk.VERTICAL, command=listbox.yview)
        listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        def apply_selection():
            selected_indices = listbox.curselection()
            selected_conditions = [listbox.get(i) for i in selected_indices]
            
            if selected_conditions:
                filtered_alignments = [a for a in self.alignment_data if a['condition'] in selected_conditions]
                if filtered_alignments:
                    self.organize_alignments_by_condition_and_radius()
                    self.create_enhanced_depth_map_from_alignments(filtered_alignments)
                else:
                    messagebox.showwarning("No Data", "No alignments match the selected conditions.")
                    self.current_depth_map = None
                    self.show_empty_plot()
                selection_window.destroy()
            else:
                messagebox.showwarning("No Selection", "Please select at least one condition")
        
        button_panel = ttk.Frame(selection_window)
        button_panel.pack(pady=10)
        ttk.Button(button_panel, text="Apply", command=apply_selection).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_panel, text="Cancel", command=selection_window.destroy).pack(side=tk.LEFT, padx=5)
    
    def show_loaded_image(self):
        if self.image_data is not None:
            self.fig.clear()
            ax = self.fig.add_subplot(111)
            ax.imshow(self.image_data)
            ax.set_title(f"Loaded Image: {self.image_data.shape[1]}x{self.image_data.shape[0]} pixels")
            ax.axis('off')
            self.canvas.draw()
    
    def cancel_processing(self):
        self.processing_cancelled = True
        self.process_status_label.config(text="Cancelling...", foreground="orange")
    
    def process_image_to_depth_map(self):
        if self.image_data is None:
            messagebox.showwarning("No Image", "Please load an image first")
            return
        try:
            self.processing_cancelled = False
            self.process_button.config(state="disabled")
            self.cancel_button.config(state="normal")
            method = self.depth_method.get()
            depth_scale_param = self.depth_scale.get()
            depth_contrast_param = self.depth_contrast.get()
            self.progress_var.set(0)
            self.root.update_idletasks()
            start_time = time.time()
            
            depth_map_raw = self.create_depth_from_image(self.image_data, method)
            
            if self.processing_cancelled:
                self.process_status_label.config(text="Processing cancelled", foreground="orange")
                return

            depth_map_adjusted = depth_map_raw * depth_scale_param
            depth_map_final = np.power(np.clip(depth_map_adjusted, 0, depth_map_adjusted.max() if depth_map_adjusted.max() > 0 else 1.0), depth_contrast_param)

            processing_time = time.time() - start_time
            self.current_depth_map = depth_map_final
            height, width = depth_map_final.shape
            x = np.linspace(0, width-1, width)
            y = np.linspace(0, height-1, height)
            self.current_coords = np.meshgrid(x, y)
            
            debug_text = (f"Method: {method}\nProcessing time: {processing_time:.2f}s\n"
                          f"Raw Depth Range: [{depth_map_raw.min():.4f}, {depth_map_raw.max():.4f}]\n"
                          f"Final Depth Range: [{depth_map_final.min():.4f}, {depth_map_final.max():.4f}]\n"
                          f"Enhanced features: {'ENABLED' if 'enhanced' in method else 'DISABLED'}")
            self.debug_label.config(text=debug_text)
            
            self.process_status_label.config(
                text=f"âœ… Processed using {method} in {processing_time:.2f}s", foreground="green"
            )
            self.update_viz_button.config(state="normal")
            self.export_button.config(state="normal")
            self.visualize_depth_map()
            messagebox.showinfo("Success", f"Image processed to depth map using {method} in {processing_time:.2f} seconds")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process image: {str(e)}")
        finally:
            self.process_button.config(state="disabled")
            self.cancel_button.config(state="disabled")
            self.progress_var.set(0)
    
    def create_depth_from_image(self, image_data, method):
        image_float = image_data.astype(np.float32) / 255.0
        depth = np.zeros((image_float.shape[0], image_float.shape[1]), dtype=np.float32)

        if method == "luminosity":
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        elif method == "rgb_magnitude":
            depth = np.sqrt(image_float[:,:,0]**2 + image_float[:,:,1]**2 + image_float[:,:,2]**2) / np.sqrt(3)
        elif method == "saturation":
            max_color = np.max(image_float, axis=2)
            min_color = np.min(image_float, axis=2)
            depth = np.where(max_color > 1e-6, (max_color - min_color) / (max_color + 1e-6), 0)
        elif method == "edges":
            gray = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
            gray_uint8 = (gray * 255).astype(np.uint8)
            edges = cv2.Canny(gray_uint8, 50, 150)
            depth = edges.astype(np.float32) / 255.0
        elif method == "gs_coordinate_enhanced":
            if self.full_sampling.get():
                depth = self._create_enhanced_gs_depth_full_sampling(image_float)
            else:
                depth = self._create_enhanced_gs_depth_sparse(image_float)
        else:
            depth = 0.299 * image_float[:,:,0] + 0.587 * image_float[:,:,1] + 0.114 * image_float[:,:,2]
        
        if depth.max() > depth.min():
             if method == "gs_coordinate_enhanced":
                 pass  # Values are already properly scaled
             else:
                 depth = (depth - depth.min()) / (depth.max() - depth.min())
        else:
            depth = np.zeros_like(depth)

        return depth

    def _calculate_s_coord_from_g_unit_and_hadit(self, g_unit_vector, hadit_3d_vector):
        """Enhanced S-coordinate calculation with quality consideration."""
        g_theta_rad = np.arctan2(g_unit_vector[1], g_unit_vector[0])
        g_phi_arg = np.clip(g_unit_vector[2], -1.0, 1.0)
        g_phi_rad = np.arccos(g_phi_arg)

        g_proj_x = np.sin(g_phi_rad) * np.cos(g_theta_rad)
        g_proj_y = np.sin(g_phi_rad) * np.sin(g_theta_rad)

        hadit_mag = np.linalg.norm(hadit_3d_vector)
        if hadit_mag < 1e-8:
            h_proj_x_term = 0.0
            h_proj_y_term = 0.0
        else:
            hadit_unit = hadit_3d_vector / hadit_mag
            hadit_theta_rad = np.arctan2(hadit_unit[1], hadit_unit[0])
            hadit_phi_arg = np.clip(hadit_unit[2], -1.0, 1.0)
            hadit_phi_rad = np.arccos(hadit_phi_arg)

            hadit_proj_x_orig = hadit_mag * np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad)
            hadit_proj_y_orig = hadit_mag * np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad)
            
            delta_theta = g_theta_rad - hadit_theta_rad
            h_proj_x_term = hadit_proj_x_orig * np.cos(delta_theta)
            h_proj_y_term = hadit_proj_y_orig * np.sin(delta_theta)

        s_x = g_proj_x - h_proj_x_term
        s_y = g_proj_y - h_proj_y_term
        
        return np.array([s_x, s_y])

    def _create_enhanced_gs_depth_full_sampling(self, image_float):
        """Enhanced G-S depth with alignment data integration."""
        height, width, _ = image_float.shape
        depth_map = np.zeros((height, width), dtype=np.float32)

        hadit_theta_rad = np.radians(self.hadit_theta.get())
        hadit_phi_rad = np.radians(self.hadit_phi.get())
        hadit_3d = np.array([
            np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad),
            np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad),
            np.cos(hadit_phi_rad)
        ])
        
        sphere_radius_sq = self.gs_scale.get()**2

        print(f"Enhanced G-S Depth (Full): Hadit={hadit_3d}, RÂ²={sphere_radius_sq}")
        print(f"Quality weighting: {self.quality_weighting.get()}")
        print(f"Perfect alignments available: {len(self.perfect_alignments)}")

        for y in range(height):
            for x in range(width):
                if self.processing_cancelled: 
                    return np.zeros((height, width))
                    
                rgb_vector = image_float[y, x]
                g_magnitude = np.linalg.norm(rgb_vector)
                
                if g_magnitude < 1e-8:
                    depth_map[y, x] = 0.0
                    continue
                
                g_unit = rgb_vector / g_magnitude
                s_coord = self._calculate_s_coord_from_g_unit_and_hadit(g_unit, hadit_3d)
                
                # Enhanced depth calculation with quality boost
                val_inside_sqrt = sphere_radius_sq - (s_coord[0]**2 + s_coord[1]**2)
                
                if val_inside_sqrt >= 0:
                    base_depth = np.sqrt(val_inside_sqrt)
                    
                    # Apply quality enhancement if we have alignment data
                    if hasattr(self, 'perfect_alignments') and self.perfect_alignments:
                        enhancement_factor = self._calculate_local_quality_enhancement(s_coord)
                        depth_map[y, x] = base_depth * enhancement_factor
                    else:
                        depth_map[y, x] = base_depth
                else:
                    depth_map[y, x] = 0.0
            
            if y % (height // 20) == 0:
                self.progress_var.set((y / height) * 100)
                self.root.update_idletasks()
        
        self.progress_var.set(100)
        return depth_map

    def _calculate_local_quality_enhancement(self, s_coord):
        """Calculate local quality enhancement based on nearby perfect alignments."""
        if not self.perfect_alignments:
            return 1.0
        
        # Find distance to nearest perfect alignment
        s_point = np.array([s_coord[0], s_coord[1]])
        min_distance = float('inf')
        
        for perfect in self.perfect_alignments:
            perfect_point = np.array([perfect['S_x'], perfect['S_y']])
            distance = np.linalg.norm(s_point - perfect_point)
            min_distance = min(min_distance, distance)
        
        # Apply enhancement based on proximity to perfect alignments
        if min_distance < 0.1:  # Very close to perfect alignment
            return 1.2
        elif min_distance < 0.2:  # Moderately close
            return 1.1
        else:
            return 1.0

    def _create_enhanced_gs_depth_sparse(self, image_float):
        """Enhanced sparse sampling with adaptive density."""
        height, width, _ = image_float.shape
        depth_map = np.zeros((height, width), dtype=np.float32)

        hadit_theta_rad = np.radians(self.hadit_theta.get())
        hadit_phi_rad = np.radians(self.hadit_phi.get())
        hadit_3d = np.array([
            np.sin(hadit_phi_rad) * np.cos(hadit_theta_rad),
            np.sin(hadit_phi_rad) * np.sin(hadit_theta_rad),
            np.cos(hadit_phi_rad)
        ])
        sphere_radius_sq = self.gs_scale.get()**2

        # Adaptive sample rate based on alignment density
        base_sample_rate = max(1, min(height//50, width//50, 10))
        if self.adaptive_sampling.get() and hasattr(self, 'perfect_alignments'):
            # Increase sampling in regions with high alignment density
            density_factor = min(len(self.perfect_alignments) / 100.0, 1.0)
            sample_rate = max(1, int(base_sample_rate * (1.0 - density_factor * 0.5)))
        else:
            sample_rate = base_sample_rate

        print(f"Enhanced G-S Depth (Sparse): Sample rate={sample_rate}, Adaptive={self.adaptive_sampling.get()}")
        
        num_steps = (height // sample_rate)
        current_step = 0

        for y_start_block in range(0, height, sample_rate):
            if self.processing_cancelled: 
                return np.zeros((height, width))
                
            for x_start_block in range(0, width, sample_rate):
                y = y_start_block
                x = x_start_block 
                
                rgb_vector = image_float[y, x]
                g_magnitude = np.linalg.norm(rgb_vector)
                depth_value = 0.0

                if g_magnitude >= 1e-8:
                    g_unit = rgb_vector / g_magnitude
                    s_coord = self._calculate_s_coord_from_g_unit_and_hadit(g_unit, hadit_3d)
                    val_inside_sqrt = sphere_radius_sq - (s_coord[0]**2 + s_coord[1]**2)
                    
                    if val_inside_sqrt >= 0:
                        base_depth = np.sqrt(val_inside_sqrt)
                        
                        # Apply quality enhancement
                        if hasattr(self, 'perfect_alignments') and self.perfect_alignments:
                            enhancement_factor = self._calculate_local_quality_enhancement(s_coord)
                            depth_value = base_depth * enhancement_factor
                        else:
                            depth_value = base_depth
                
                # Fill the block
                y_end_block = min(height, y_start_block + sample_rate)
                x_end_block = min(width, x_start_block + sample_rate)
                depth_map[y_start_block:y_end_block, x_start_block:x_end_block] = depth_value
            
            current_step += 1
            if num_steps > 0:
                 self.progress_var.set((current_step / num_steps) * 100)
                 self.root.update_idletasks()
        
        self.progress_var.set(100)
        return depth_map

    def test_gs_method(self):
        size = 256
        test_image = np.zeros((size, size, 3), dtype=np.float32)
        for y in range(size):
            for x in range(size):
                center_x, center_y = size // 2, size // 2
                distance = np.sqrt((x - center_x)**2 + (y - center_y)**2)
                normalized_distance = np.clip(distance / (size // 2), 0, 1)
                test_image[y, x, 0] = np.sin(x / size * np.pi * 2) * 0.5 + 0.5
                test_image[y, x, 1] = np.cos(y / size * np.pi * 2) * 0.5 + 0.5
                test_image[y, x, 2] = 1.0 - normalized_distance
        
        self.image_data = (np.clip(test_image, 0, 1) * 255).astype(np.uint8)
        self.loaded_image = Image.fromarray(self.image_data)
        self.image_status_label.config(text=f"âœ… Enhanced test pattern created ({size}x{size})", foreground="green")
        self.process_button.config(state="normal")
        self.process_status_label.config(text="Enhanced test pattern ready", foreground="blue")
        self.show_loaded_image()
        self.depth_method.set("gs_coordinate_enhanced")
        self.full_sampling.set(True)
        self.quality_weighting.set(True)
        messagebox.showinfo("Test Pattern", "Enhanced synthetic pattern loaded for testing.")
    
    def visualize_depth_map(self):
        if self.current_depth_map is None: 
            return
            
        self.fig.clear()
        
        method_title_name = self.depth_method.get()
        if method_title_name == "gs_coordinate_enhanced":
            method_title_name = "Enhanced G-S Depth"

        sampling_mode = "Full" if self.full_sampling.get() else "Sparse"
        enhancement_features = []
        if self.quality_weighting.get():
            enhancement_features.append("Quality-Weighted")
        if self.multi_condition_fusion.get():
            enhancement_features.append("Multi-Condition")
        if self.adaptive_sampling.get():
            enhancement_features.append("Adaptive")
        
        features_str = " + ".join(enhancement_features) if enhancement_features else "Standard"
        title_suffix = f" ({method_title_name} - {sampling_mode}, {features_str})"

        if self.image_data is not None:
            ax1 = self.fig.add_subplot(131)
            ax1.imshow(self.image_data)
            ax1.set_title("Original Image")
            ax1.axis('off')
            
            ax2 = self.fig.add_subplot(132)
            im = ax2.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto')
            ax2.set_title(f"Depth Map{title_suffix}")
            ax2.axis('off')
            
            ax3 = self.fig.add_subplot(133)
            if self.current_depth_map.size > 0:
                 ax3.hist(self.current_depth_map.flatten(), bins=50, alpha=0.7, color='blue')
            ax3.set_xlabel("Depth Value")
            ax3.set_ylabel("Pixel Count")
            ax3.set_title(f"Enhanced Depth Dist.\nRange: [{self.current_depth_map.min():.3f}, {self.current_depth_map.max():.3f}]")
            self.fig.colorbar(im, ax=ax2, label='Enhanced Depth', shrink=0.6)
        else:
            ax = self.fig.add_subplot(111)
            im = ax.imshow(self.current_depth_map, cmap=self.colormap.get(), aspect='auto')
            ax.set_title(f"Depth Map{title_suffix}")
            ax.axis('off')
            self.fig.colorbar(im, ax=ax, label='Enhanced Depth', shrink=0.8)
        
        self.fig.tight_layout()
        self.canvas.draw()
    
    def update_visualization(self):
        if self.current_depth_map is not None:
            if hasattr(self, 'alignment_data') and self.alignment_data and not self.image_data:
                self.visualize_enhanced_alignment_depth_map(self.alignment_data)
            else:
                self.visualize_depth_map()
        else:
            self.show_empty_plot()
    
    def export_depth_map(self):
        if self.current_depth_map is None:
            messagebox.showwarning("No Depth Map", "Please process data first")
            return
        
        filename = filedialog.asksaveasfilename(
            title="Save Enhanced Depth Map As",
            defaultextension=".png",
            filetypes=[
                ("PNG image", "*.png"), 
                ("NumPy array", "*.npy"),
                ("CSV file", "*.csv"),
                ("All files", "*.*")
            ]
        )
        if not filename: 
            return

        try:
            file_ext = os.path.splitext(filename)[1].lower()
            if file_ext == ".png":
                # Normalize to 0-255 for image saving
                depth_norm = self.current_depth_map
                if depth_norm.max() > depth_norm.min():
                    depth_norm = (depth_norm - depth_norm.min()) / (depth_norm.max() - depth_norm.min())
                
                # Apply colormap if user wants colored PNG, or save grayscale
                img_array = (depth_norm * 255).astype(np.uint8)
                img = Image.fromarray(img_array, mode='L')
                img.save(filename)
                messagebox.showinfo("Export Success", f"Enhanced depth map saved as PNG: {filename}")
            elif file_ext == ".npy":
                np.save(filename, self.current_depth_map)
                messagebox.showinfo("Export Success", f"Enhanced depth map saved as NPY: {filename}")
            elif file_ext == ".csv":
                np.savetxt(filename, self.current_depth_map, delimiter=",")
                messagebox.showinfo("Export Success", f"Enhanced depth map saved as CSV: {filename}")
            else:
                messagebox.showerror("Unsupported Format", "Please choose .png, .npy, or .csv")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export enhanced depth map: {str(e)}")

    def load_sample_data(self):
        """Loads a sample G-S alignment data file for quick testing."""
        # Create enhanced dummy alignment file content with your actual data structure
        dummy_content = """
S-NUIT ALIGNMENT DATA EXPORT
==================================================
Generated: 2025-06-08 19:38:41
Total conditions analyzed: 9
Total alignments found: 142332

SUMMARY BY CONDITION:
------------------------------
XY projection, radius 0.5: 8904 alignments
XY projection, radius 1.0: 31608 alignments
XY projection, radius 1.5: 0 alignments
XZ projection, radius 0.5: 6116 alignments
XZ projection, radius 1.0: 45216 alignments
XZ projection, radius 1.5: 0 alignments
YZ projection, radius 0.5: 6944 alignments
YZ projection, radius 1.0: 43544 alignments
YZ projection, radius 1.5: 0 alignments

================================================================================
CONDITION: XY PROJECTION, NUIT RADIUS = 0.5
================================================================================
Number of alignments: 8904

STATISTICAL SUMMARY:
--------------------
Distance from boundary - Mean: 0.014957, Min: 0.000000, Max: 0.049969
Distance from origin - Mean: 0.502884, Min: 0.450031, Max: 0.549907
G Î¸ range: [0.0Â°, 360.0Â°]
G Ï† range: [10.0Â°, 170.0Â°]
Hadit Î¸ range: [0.0Â°, 360.0Â°]
Hadit Ï† range: [0.0Â°, 180.0Â°]
S X range: [-0.545, 0.549]
S Y range: [-0.548, 0.548]

BEST ALIGNMENT:
---------------
G(Î¸=0.00Â°, Ï†=10.00Â°), Hadit(Î¸=0.00Â°, Ï†=20.00Â°)
S=(-0.500000, 0.000000), boundary distance=0.00000000

DETAILED ALIGNMENT DATA:
-------------------------
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
0.00,10.00,0.00,20.00,-0.500000,0.000000,0.00000000,0.500000,-0.500000,0.000000,-0.866025
0.00,10.00,0.00,80.00,-0.500000,0.000000,0.00000000,0.500000,-0.500000,0.000000,0.866025
0.00,10.00,21.18,20.00,-0.451952,-0.242359,0.01283360,0.512834,-0.451952,-0.242359,-0.858488
10.29,10.00,0.00,20.00,-0.502138,0.031006,0.00309410,0.503094,-0.502138,0.031006,-0.864232
10.29,10.00,0.00,80.00,-0.497378,0.031006,0.00165680,0.498343,-0.497378,0.031006,0.866980
================================================================================
CONDITION: XZ PROJECTION, NUIT RADIUS = 0.5
================================================================================
Number of alignments: 6116
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
15.00,20.00,10.00,30.00,-0.400000,0.200000,0.00500000,0.447214,-0.400000,0.100000,0.200000
20.00,25.00,15.00,35.00,-0.350000,0.150000,0.00200000,0.377492,-0.350000,0.120000,0.150000
================================================================================
CONDITION: YZ PROJECTION, NUIT RADIUS = 0.5
================================================================================
Number of alignments: 6944
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
25.00,30.00,20.00,40.00,0.300000,-0.250000,0.00100000,0.390512,0.200000,0.300000,-0.250000
30.00,35.00,25.00,45.00,0.250000,-0.200000,0.00050000,0.320156,0.150000,0.250000,-0.200000
================================================================================
CONDITION: XY PROJECTION, NUIT RADIUS = 1.0
================================================================================
Number of alignments: 31608
G_theta_deg,G_phi_deg,Hadit_theta_deg,Hadit_phi_deg,S_x,S_y,dist_boundary,dist_origin,G_refl_x,G_refl_y,G_refl_z
0.00,15.00,5.00,25.00,-0.900000,0.100000,0.10000000,0.905539,-0.900000,0.100000,-0.424264
5.00,20.00,10.00,30.00,-0.850000,0.150000,0.08000000,0.863134,-0.850000,0.150000,-0.503322
""".strip()
        
        # Write to temporary file
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False) as temp_file:
            temp_file.write(dummy_content)
            temp_filename = temp_file.name
        
        try:
            self.parse_gs_alignment_file(temp_filename)
            self.image_status_label.config(text="âœ… Enhanced sample data loaded", foreground="green")
            self.process_status_label.config(text="Sample alignment data ready for enhanced processing", foreground="blue")
            
            # Enable enhanced features for demonstration
            self.quality_weighting.set(True)
            self.multi_condition_fusion.set(True)
            self.adaptive_sampling.set(True)
            self.auto_optimize_params.set(True)
            
            messagebox.showinfo("Sample Data", 
                              f"Enhanced sample data loaded!\n"
                              f"â€¢ {len(self.alignment_data)} total alignments\n"
                              f"â€¢ {len(self.perfect_alignments)} perfect alignments\n"
                              f"â€¢ {len(self.alignments_by_condition)} conditions\n"
                              f"â€¢ All enhancement features enabled")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load sample data: {str(e)}")
        finally:
            # Clean up temp file
            try:
                os.unlink(temp_filename)
            except:
                pass


if __name__ == "__main__":
    root = tk.Tk()
    app = GSDepthMapperGUI(root)
    root.mainloop()
